package talk.window;import java.util.LinkedList;/** * 滑动窗口: 窗口内的最大/小值的更新 *    问题: 假设有一个固定大小为 W 的窗口, 依次划过 arr[] , 求返回每一次滑出状况的最大值 */public class WindowSliding {    /**     * 窗口内最大值的更新结构     * @param arr 目标数组     * @param w 窗口长度     * @return 窗口长度最大值的数组     */    public static int[] window(int[] arr, int w){        if (arr == null || arr.length < 1 || w < 1){            return null;        }        //双端队列, 存放数组下标        LinkedList<Integer> list = new LinkedList<>();        int[] res = new int[arr.length - w + 1];        int  index = 0;        for (int i = 0; i < arr.length; i++) {            //最大值的更新, 当队列有元素 而且 之后一个元素 <= 当前元素, 需要将最后一个元素从队列中弹出, 循环往复, 确保队列中第一个元素最大            while  (!list.isEmpty() && arr[list.peekLast()] <= arr[i]){                list.pollLast();            }            list.addLast(i);            //当前队列中的数据是否超过窗口长度            if (list.peekFirst() == (i - w)){                list.pollFirst();            }            //当前来到窗口限定值, 则需要保存结果            if (i >= w - 1) {                res[index++] = arr[list.peekFirst()];            }        }        return  res;    }    //暴力递归 : 测试滑动窗口    public static int[] testWindow(int[] arr, int w){        if (arr == null || arr.length < 1 || w < 1){            return null;        }        int[] res = new int[arr.length - w + 1];        process(arr, res, 0, w);        return res;    }    /**     * 递归执行方法     * @param arr 目标数据     * @param res 结果数组     * @param index 当前来到的索引下标     * @param w  测试长度     */    private static void process(int[] arr, int[] res, int index, int w){        if (index != arr.length - w + 1){            int max = arr[index];            for (int i = 0; i < w; i++) {                max = Math.max(arr[index + i],max);            }            res[index] = max;            process(arr, res,index + 1, w);        }    }    private static int[] generateRandOne(int maxLength, int maxValue){        int len = (int)(Math.random() * maxLength) + 1;        int[] arr = new int[len];        for (int i = 0; i < len; i++) {            arr[i] = (int)(Math.random() * maxValue) + 1;        }        return arr;    }    public static void main(String[] args) {        int maxLength = 100;        int maxValue = 1000;        int testTime = 10000;        System.out.println("测试开始!");        for (int i = 0; i < testTime; i++) {            int[] ints = generateRandOne(maxLength, maxValue);            int w = (int)(Math.random() * ints.length) + 1;            int[] window = window(ints, w);            int[] testWindow = testWindow(ints, w);            for (int j = 0; j < window.length; j++) {                if (window[j] != testWindow[j]){                    System.out.println("Oops");                    return;                }            }        }        System.out.println("测试结束!");    }}