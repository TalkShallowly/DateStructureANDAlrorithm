package talk.window;import java.util.Arrays;import java.util.LinkedList;/** * 滑动窗口: 加油站的良好加油问题 *      问题: *           在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 *           你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 *           给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 * *           eg : 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] *                  输出: 3 *                  解释: *                  从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 *                  开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 *                  开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 *                  开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 *                  开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 *                  开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 *                  因此，3 可为起始索引。 * * *           解题思路: 使用滑动窗口一次遍历 O(n) *              1: 首先将加油站的 油 和 路径 做判断 (做减法: < 0 则无法到达) 生成判断条件 *              2: 再将判断条件 生成 对应路径和 (核心点: 窗口内的最小值如果 > 0 则是可以跑完全程的点) * * 测试链接：https://leetcode.com/problems/gas-station */public class GasStation {    public static int canCompleteCircuit(int[] gas, int[] cost){        if (gas == null || gas.length == 0 || cost == null || cost.length == 0 || gas.length != cost.length){            return -1;        }        int[] minSun = minSumArray(gas, cost);        //最小值窗口数据        LinkedList<Integer> minWindow = new LinkedList<>();        int N = gas.length;        int R = 0;        for (int L = 0; L < N; L++) {            //窗口初始长度            while (R < N + L){                while (!minWindow.isEmpty() && minSun[minWindow.peekLast()] >= minSun[R]) {                    minWindow.pollLast();                }                minWindow.addLast(R);                //当前窗口长度                if (R >= gas.length - 1){                    int sign = minSun[minWindow.getFirst()] - (R - N < 0 ? 0 : minSun[R - N]);                    if (sign  >= 0){                        return minWindow.getFirst() - N + 1;                    }else {                        if (minWindow.getFirst() == L){                            minWindow.pollFirst();                        }                    }                }                R++;            }        }        return -1;    }    //生成路径油耗数组    private static int[] minSumArray(int[] gas, int[] cost){        int N =  gas.length;        //从最后的一个点出发, 跑完全程到 前一个结束        int[] res = new int[N * 2 - 1];        for (int i = 0; i < res.length; i++) {            res[i] = i >= N ? gas[i - N] - cost[i - N] : gas[i] - cost[i];            res[i] = i > 0 ? res[i] + res[i - 1] : res[i];        }        return res;    }    public static void main(String[] args) {        int[] gas = {1,2};        int[] cost = {2,1};        System.out.println(canCompleteCircuit(gas, cost));        int[] ints = minSumArray(gas, cost);        System.out.println(Arrays.toString(ints));    }    public static int canCompleteCircuit2(int[] gas, int[] cost) {        boolean[] good = goodArray(gas, cost);        for (int i = 0; i < gas.length; i++) {            if (good[i]) {                return i;            }        }        return -1;    }    public static boolean[] goodArray(int[] g, int[] c) {        int N = g.length;        int M = N << 1;        int[] arr = new int[M];        for (int i = 0; i < N; i++) {            arr[i] = g[i] - c[i];            arr[i + N] = g[i] - c[i];        }        for (int i = 1; i < M; i++) {            arr[i] += arr[i - 1];        }        LinkedList<Integer> w = new LinkedList<>();        for (int i = 0; i < N; i++) {            while (!w.isEmpty() && arr[w.peekLast()] >= arr[i]) {                w.pollLast();            }            w.addLast(i);        }        boolean[] ans = new boolean[N];        for (int offset = 0, i = 0, j = N; j < M; offset = arr[i++], j++) {            if (arr[w.peekFirst()] - offset >= 0) {                ans[i] = true;            }            if (w.peekFirst() == i) {                w.pollFirst();            }            while (!w.isEmpty() && arr[w.peekLast()] >= arr[j]) {                w.pollLast();            }            w.addLast(j);        }        return ans;    }}