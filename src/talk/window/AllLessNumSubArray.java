package talk.window;import java.util.LinkedList;/** * 滑动窗口问题: *      给定一个整数数组 arr[], 和一个整数 num, 某个 arr[]中的子数组 sub, *          如果想要达标则必须满足 sub 中最大值 - sub 中最小值 <= num *          返回 arr[] 中达标子数组的数量 (子数组一定连续) * *      分析: 若一个范围 L ~ R 上达标, 则在 L ~ R 范围内的子数组都达标 */public class AllLessNumSubArray {    public static int window(int[] arr, int num) {        if (arr == null || arr.length < 1 || num < 0){            return 0;        }        int res = 0;        //最大值窗口        LinkedList<Integer> maxWindows = new LinkedList<>();        //最小值窗口        LinkedList<Integer> minWindows = new LinkedList<>();        int R = 0;        for (int L = 0; L < arr.length; L++) {            while (R < arr.length){                //更新最大值窗口                while (!maxWindows.isEmpty() && arr[maxWindows.peekLast()] <= arr[R]){                    maxWindows.pollLast();                }                maxWindows.addLast(R);                //更新最小值窗口                while (!minWindows.isEmpty() && arr[minWindows.peekLast()] >= arr[R]){                    minWindows.pollLast();                }                minWindows.addLast(R);                if (arr[maxWindows.peekFirst()] - arr[minWindows.peekFirst()] <= num){                    R++;                }else {                    break;                }            }            //假设在 L ~ R 范围上符合条件, 则 L ~ R 范围内所有子序列都符合条件            res += R - L;            while (!maxWindows.isEmpty() && maxWindows.peekFirst() == L) {                maxWindows.pollFirst();            }            while (!minWindows.isEmpty() && minWindows.peekFirst() == L) {                minWindows.pollFirst();            }        }        return res;    }    public static int testWindow(int[] arr, int num){        if (arr == null || arr.length < 1 || num < 0){            return 0;        }        int N = arr.length;        int res = 0;        for (int L = 0; L < N; L++) {            for (int R = L; R < N; R++) {                int max = arr[L];                int min = arr[L];                //遍历数据找出最大最小值                for (int j = L; j <= R; j++) {                    max = Math.max(max,arr[j]);                    min = Math.min(min,arr[j]);                }                if ((max - min) <= num){                    res++;                }            }        }        return res;    }    private static int[] generateRandomArray(int maxLength, int maxValue){        int len = (int)(Math.random() * maxLength) + 1;        int[] arr = new int[len];        for (int i = 0; i < len; i++) {            arr[i] = (int)(Math.random() * maxValue) + 1;        }        return arr;    }    public static void main(String[] args) {        int maxLength = 100;        int maxValue = 1000;        int testTime = 10000;        System.out.println("测试开始!");        for (int i = 0; i < testTime; i++) {            int[] ints = generateRandomArray(maxLength, maxValue);            int num = (int)(Math.random() * ints.length) + 1;            int window = window(ints, num);            int testWindow = testWindow(ints, num);            if (window != testWindow){                System.out.println("Oops");                return;            }        }        System.out.println("测试结束!");    }}