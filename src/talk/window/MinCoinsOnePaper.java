package talk.window;import java.util.HashMap;import java.util.LinkedList;import java.util.Map;/** * 最少货币问题: *      arr[] 是货币数组, 其中的值都是正数, 在给定一个正数 aim, 每个值都可以认为是一张货币, *      求返回组成 aim 的最少货币数 * *      策略一: 不统计货币数组 *      策略二: 统计货币数组 *          使用滑动窗口优化 (数量量较大, 但是重复货币数较多) * */public class MinCoinsOnePaper {    static class Info{        private final int[] coins;        private final int[] num;        Info(int[] _coins, int[] _num){            this.coins = _coins;            this.num = _num;        }    }    /**     * 递归策略一: 直接使用costs 数组进行遍历     * @param arr 货币数组     * @param aim 目标金额     * @return 最小金额数     */    public static int minCoins(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        return  process(arr, 0, aim);    }    private static int process(int[] arr, int index, int aim) {        //如果在 index 到达后, 如果目标已已经被完成, 则返回 0 ,在上层调用进行统计操作        if (index == arr.length) {            return aim == 0 ? 0 : Integer.MAX_VALUE;        }        //当前选择的金额过大        if (aim < 0) {            return Integer.MAX_VALUE;        }        //不需要当前索引的金额        int res = process(arr, index + 1, aim);        //需要当前索引的金额        int p2 = process(arr, index + 1, aim - arr[index]);        if (p2 != Integer.MAX_VALUE) {            //如果 p2 按照条件完成, 则需要 加 1            res = Math.min(res, p2 + 1);        }        return res;    }    /**     *  动态规划 : 递归策略一     */    public static int dp1(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        int N = arr.length;        int[][] dp = new int[N + 1][aim + 1];        //dp 初始化        dp[N][0] = 0;        for (int i = 1; i <= aim; i++) {            dp[N][i] = Integer.MAX_VALUE;        }        for (int index = N - 1; index >= 0; index--) {            for (int target = 0; target <= aim; target++) {                dp[index][target] = dp[index + 1][target];                if (target - arr[index] >= 0 && dp[index + 1][target - arr[index]] != Integer.MAX_VALUE){                    dp[index][target] = Math.min(dp[index][target], dp[index + 1][target - arr[index]] + 1);                }            }        }        return dp[0][aim];    }    /**     * 递归策略 二: 因为 costs 数组中可能有相同金额的数据, 若相同数据出现次数过大且过多,则进行货币与货币数的统计     * @param arr 货币数组     * @param aim 目标金额     * @return 最少货币数     */    public static int minCoins2(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        Info info = getInfo(arr);        return  process2(info, 0, aim);    }    private static int process2(Info info, int index, int aim){        int[] coins = info.coins;        int[] num = info.num;        if (index == coins.length){            return aim == 0 ? 0 : Integer.MAX_VALUE;        }        //不需要当前索引值        int p1 = process2(info, index + 1, aim);        int res = Integer.MAX_VALUE;        //循环遍历相同的货币数        for (int zhang = 1; zhang <= num[index] && (zhang * coins[index]) <= aim; zhang++) {            int p2 = process2(info, index + 1, aim - (zhang * coins[index]));            if (p2 != Integer.MAX_VALUE){                res = Math.min(res, p2 + zhang);            }        }        return Math.min(p1, res);    }    /**     * 动态规划二 : 递归策略二     * @param arr 货币数组     * @param aim 目标金额     * @return 最少货币数     */    public static int dp2(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        Info info = getInfo(arr);        int[] coins = info.coins;        int[] num = info.num;        int N = coins.length;        int[][] dp = new int[N + 1][aim + 1];        dp[N][0] = 0;        for (int i = 1; i <= aim; i++) {            dp[N][i] = Integer.MAX_VALUE;        }        for (int index = N - 1; index >= 0; index--) {            for (int target = 0; target <= aim; target++) {                int p1 = dp[index + 1][target];                int res = Integer.MAX_VALUE;                for (int zhang = 1; zhang <= num[index] && (zhang * coins[index]) <= aim; zhang++) {                    if ((target - (zhang * coins[index])) >= 0){                        int p2 = dp[index + 1][target - (zhang * coins[index])];                        if (p2 != Integer.MAX_VALUE) {                            res = Math.min(res, p2 + zhang);                        }                    }                }                dp[index][target] = Math.min(p1, res);            }        }        return dp[0][aim];    }    /**     * 使用滑动窗口优化 dp 中的枚举策略     * @param arr 货币数组     * @param aim 目标数组     * @return 最少货币数     */    public static int dp3(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        Info info = getInfo(arr);        int[] coins = info.coins;        int[] num = info.num;        int N = coins.length;        int[][] dp = new int[N + 1][aim + 1];        dp[N][0] = 0;        for (int i = 1; i <= aim; i++) {            dp[N][i] = Integer.MAX_VALUE;        }        for (int index = N - 1; index >= 0; index--) {            //Math.min(aim + 1, coins[index]) 为 窗口的左边界的最大值            for (int L = 0; L < Math.min(aim + 1, coins[index]); L++) {                LinkedList<Integer> minWindow = new LinkedList<>();                dp[index][L] = dp[index + 1][L];                minWindow.add(L);                // 跳跃性更新 当前面值 X                // L  L + x   L + 2*x   L + 3 * x                for (int R = L + coins[index]; R <= aim; R += coins[index]) {                    //比较更新的时候 需要加上前面的补偿值 (因为前面元素需要加上缺失的货币数)                    while (!minWindow.isEmpty()                            && (dp[index + 1][minWindow.peekLast()] == Integer.MAX_VALUE                            || dp[index + 1][minWindow.peekLast()] + (R - minWindow.peekLast()) / coins[index] >= dp[index + 1][R])) {                        minWindow.pollLast();                    }                    minWindow.addLast(R);                    int overdue = R - (coins[index] * (num[index] + 1));                    if (!minWindow.isEmpty() && minWindow.peekFirst() == overdue) {                        minWindow.pollFirst();                    }                    // (R - minWindow.getFirst()) / coins[index] 补偿机制                    dp[index][R] = dp[index + 1][minWindow.getFirst()] + (R - minWindow.getFirst()) / coins[index];                }            }        }        return dp[0][aim];    }    /**     * 统计货币数组中,不同货币出现的次数     * @param arr 货币数组     * @return 货币数组 + 统计数组     */    public static Info getInfo(int[] arr){        Map<Integer, Integer> map = new HashMap<>();        for (int j : arr) {            if (map.containsKey(j)) {                map.put(j, map.get(j) + 1);            }else {                map.put(j, 1);            }        }        int[] coins = new int[map.size()];        int[] num = new int[map.size()];        int index = 0;        for (Map.Entry<Integer, Integer> entry : map.entrySet()){            coins[index] = entry.getKey();            num[index++] = entry.getValue();        }        return new Info(coins, num);    }    private static int[] generateRandomArray(int maxLen, int maxValue){        int len = (int)(Math.random() * maxLen) + 1;        int[] coins = new int[len];        for (int i = 0; i < len; i++) {           coins[i] =  (int)(Math.random() * maxValue) + 1;        }        return coins;    }    public static void main(String[] args) {        int maxLen = 10;        int maxValue = 10;        int maxAim = 10;//        int timeCount = 100;//        System.out.println("测试开始!");//        for (int i = 0; i < timeCount; i++) {//            int[] ints = generateRandomArray(maxLen, maxValue);//            int aim = (int) (Math.random() * maxAim) + 1;//            int minCoins = minCoins(ints, aim);//            int dp3 = dp3(ints, aim);//            if (dp3 != minCoins){//                System.out.println("目标金额: " + aim);//                System.out.println("当前数组: " + Arrays.toString(ints));//                System.out.println("dp3: " + dp3 + " |---| minCoins: " + minCoins);//                return;//            }//        }//        System.out.println("测试结束!");        System.out.println("性能测试开始");        maxLen = 10000;        maxValue = 200;        maxAim = 6000;        long time1,time2,time3,time4,time5,time6,time7,time8;        int ans1,ans2,ans3,ans4,ans5,ans6,ans7;        int[] ints = generateRandomArray(maxLen, maxValue);        System.out.println(" *** 策略一 : 不统计货币数组");//        time1 = System.currentTimeMillis();//        ans1 = minCoins(ints,maxAim);        time2 = System.currentTimeMillis();        ans2 = dp1(ints,maxAim);        time3 = System.currentTimeMillis();//        System.out.println(" *** *** 暴力递归 : " + ans1 + ", 运行时间 : " + (time2 - time1) + " ms");        System.out.println(" *** *** 动态规划 : " + ans2 + ", 运行时间 : " + (time3 - time2) + " ms");        System.out.println("----------------------");        System.out.println(" *** 策略二 : 统计货币数组");//        time1 = System.currentTimeMillis();//        ans1 = minCoins2(ints,maxAim);        time2 = System.currentTimeMillis();        ans2 = dp2(ints,maxAim);        time3 = System.currentTimeMillis();        ans3 = dp3(ints,maxAim);        time4 = System.currentTimeMillis();//        System.out.println(" *** *** 暴力递归 : " + ans1 + ", 运行时间 : " + (time2 - time1) + " ms");        System.out.println(" *** *** 动态规划 : " + ans2 + ", 运行时间 : " + (time3 - time2) + " ms");        System.out.println(" *** *** 动态规划 (滑动窗口) : " + ans3 + ", 运行时间 : " + (time4 - time3) + " ms");        System.out.println("----------------------");        System.out.println("性能测试结束");        System.out.println("===========");        System.out.println("货币大量重复出现情况下，");//        System.out.println("大数据量测试dp3开始");        maxLen = 200000;        maxAim = 1000;        maxValue = 1000;        ints = generateRandomArray(maxLen, maxValue);        time1 = System.currentTimeMillis();        ans1 = dp1(ints, maxAim);        time2 = System.currentTimeMillis();        ans2 = dp2(ints, maxAim);        time3 = System.currentTimeMillis();        ans3 = dp3(ints, maxAim);        time4 = System.currentTimeMillis();//        System.out.println("*** dp1 : 运行时间 : " + (time2 - time1) + " ms");//        System.out.println("*** dp2 : 运行时间 : " + (time3 - time2) + " ms");        System.out.println("*** dp3 : 运行时间 : " + (time4 - time3) + " ms");        System.out.println("大数据量测试dp3结束");//        System.out.println("===========");////        System.out.println("当货币很少出现重复，dp2比dp3有常数时间优势");//        System.out.println("当货币大量出现重复，dp3时间复杂度明显优于dp2");//        System.out.println("dp3的优化用到了窗口内最小值的更新结构");    }}