package talk.greedy;import java.util.Comparator;import java.util.PriorityQueue;/** * 题目: 输入 : 正树数组 costs[], 正数数组 profits,正数 K ,正数 m *      其中:  costs[i] 表示第 i 号项目的花费 *            profits[i], 表示第 i 号项目在扣除花费之后所得到的钱 (纯利润) *            K : 表示最多可以串行做多少个项目 (在串行的过程中,其保证所拥有的钱可以进行项目的开始) *            M : 表示初始的资金 *       解释: *          没做完一个项目,就会马上获得的收益,可以支持去做下一个项目, 不可以并行做项目 *       输出: 最后做项目是获得的做大钱数 * *       解题思路: 贪心算法 ---> 需要两个堆结构,大根堆和小根堆 *          贪心策略: 游戏打怪升级最快思路 */public class IPO {    public static class Project{        private final int cost;        private final int profit;        Project(int _cost, int _profit){            this.cost = _cost;            this.profit = _profit;        }    }    public static class MaxProfitComparator implements Comparator<Project> {        @Override        public int compare(Project o1, Project o2) {            return o2.profit - o1.profit;        }    }    public static class MinCostComparator implements Comparator<Project> {        @Override        public int compare(Project o1, Project o2) {            return o1.cost - o2.cost;        }    }    public static int maxProjectIncome(int[] costs,int[] profits, int k, int m){        PriorityQueue<Project> maxProfitHead = new PriorityQueue<>(new MaxProfitComparator());        PriorityQueue<Project> minCostHead = new PriorityQueue<>(new MinCostComparator());        for (int i = 0; i < costs.length; i++) {            minCostHead.add(new Project(costs[i], profits[i]));        }        for (int i = 0; i < k; i++) {            while (!minCostHead.isEmpty() && minCostHead.peek().cost <= m){                maxProfitHead.add(minCostHead.poll());            }            if (maxProfitHead.isEmpty()){                return m;            }            m += maxProfitHead.poll().profit;        }        return m;    }}