package talk.greedy;import java.util.Arrays;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;import java.util.stream.Stream;/** * 问题: 一个项目要占用一个会议室宣讲,会议室不能同时容纳两个项目的宣讲,假设给定每个项目的开始时间和结束时间,以此来合理安排宣讲的日程,要求会议室 *      进行的宣讲的场次最多,求返回最多的宣讲场次 *          规定: 会议的开始时间和结束时间都时正整数 * *          贪心策略: *              1: 不能以开始时间为基准进行, 开始时间确定但是结束时间是未知状态 *              2: 以结束时间为基准进行, 将数据以结束时间为基准存放到小根堆中,在逐次弹出的时间进行开始时间与结束时间的判定 * */public class BestArrange {    public static class Program {        public int start;        public int end;        public Program(int start, int end) {            this.start = start;            this.end = end;        }    }    /**     * 贪心解: 小根堆法     */    public static int bestArrange(Program[] programs) {        if (programs.length <= 1){            return programs.length;        }        //第一: 将数据按照结束日期排序添加到小根堆中        PriorityQueue<Program> queue = addPrograms(programs);        Program curProgram = queue.poll();        int ans = 1;        while (!queue.isEmpty()){            Program poll = queue.poll();            assert curProgram != null;            if (curProgram.end <= poll.start){                curProgram = poll;                ans++;            }        }        return ans;   }   private static PriorityQueue<Program> addPrograms(Program[] programs){       PriorityQueue<Program> queue = new PriorityQueue<>(new programComparator());       queue.addAll(Arrays.asList(programs));       return queue;   }    /**     * 实现结束时间比较器     */   public static class programComparator implements Comparator<Program> {       @Override       public int compare(Program o1, Program o2) {           return o1.end - o2.end;       }   }    /**     * 对数器 : 暴力破解法     */   public static int bestArrangeCheck(Program[] programs){       if (programs.length == 0 || programs == null){           return 0;       }       return process(programs,0,0);   }    /**     * 递归执行所有的可能性分析     * @param pros 当前所剩下的所有项目会议     * @param done 之前已经安排的会议场次数量     * @param timeLine 当前已经来到的时间线     * @return 会议场次     */   private static int process(Program[] pros,int done,int timeLine){       if (pros.length == 0){           return done;       }       int max = done;       for (int i = 0; i < pros.length; i++) {           if (pros[i].start >= timeLine) {               Program[] programs = removeIndexPrograms(pros, i);               max = Math.max(max,process(programs, done + 1, pros[i].end));           }       }       return max;   }    /**     * 移除指定索引处的元素     */   private static Program[] removeIndexPrograms(Program[] programs, int index){       Program[] newPrograms = new Program[programs.length - 1];       int ans = 0;       for (int i = 0; i < programs.length; i++) {           if (i != index){               newPrograms[ans++] = programs[i];           }       }       return newPrograms;   }    public static Program[] generatePrograms(int programSize, int timeMax) {        Program[] ans = new Program[(int) (Math.random() * (programSize + 1))];        for (int i = 0; i < ans.length; i++) {            int r1 = (int) (Math.random() * (timeMax + 1));            int r2 = (int) (Math.random() * (timeMax + 1));            if (r1 == r2) {                ans[i] = new Program(r1, r1 + 1);            } else {                ans[i] = new Program(Math.min(r1, r2), Math.max(r1, r2));            }        }        return ans;    }    public static void main(String[] args) {        int programSize = 12;        int timeMax = 20;        int timeTimes = 1000000;        System.out.println("start....");        for (int i = 0; i < timeTimes; i++) {            Program[] programs = generatePrograms(programSize, timeMax);            if (bestArrange(programs) != bestArrangeCheck(programs)) {                System.out.println("Oops!");            }        }        System.out.println("finish!");    }}