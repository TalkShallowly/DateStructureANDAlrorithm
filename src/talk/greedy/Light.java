package talk.greedy;import java.util.HashSet;import java.util.Objects;/** * 题目: 给定一个字符串, 只由 X 和 . 两种字符构成 *          X 表示墙, 不可以放灯, 也不需要点亮 *          . 表示居民点, 可以当灯, 需要点亮 *    解释: *         如果灯放在 i 的位置, 可以让 i - 1, i 和 i + 1 三个位置都可以被照亮, *          求返回如点亮 str 中需要点亮的位置, 至少需要几盏灯 */public class Light {    public static int minLight_01(String str){        if (str == null || str.length() == 0){            return 0;        }        String[] xes = str.split("X");        int ans = 0;        for (String x : xes) {            if (x.length() != 0) {                if (x.length() <= 3) {                    ans++;                } else {                    ans += x.length() % 3 == 0 ? x.length() / 3 : x.length() / 3 + 1;                }            }        }        return ans;    }    public static int minLight_02(String str){        if (str == null || str.length() == 0){            return 0;        }        char[] chars = str.toCharArray();        int ans = 0;        int i = 0;        while  (i < chars.length) {            if (chars[i] == 'X'){                i += 1;            }else {                ans++;                if (i + 1 == chars.length){                    break;                }else {                    if (chars[i + 1] == 'X'){                        i += 2;                    }else {                        i += 3;                    }                }            }        }        return ans;    }    public static int minLight_03(String road) {        if (road == null || road.length() == 0) {            return 0;        }        return process(road.toCharArray(), 0, new HashSet<>());    }    // str[index....]位置，自由选择放灯还是不放灯    // str[0..index-1]位置呢？已经做完决定了，那些放了灯的位置，存在lights里    // 要求选出能照亮所有.的方案，并且在这些有效的方案中，返回最少需要几个灯    public static int process(char[] str, int index, HashSet<Integer> lights) {        if (index == str.length) { // 结束的时候            for (int i = 0; i < str.length; i++) {                if (str[i] != 'X') { // 当前位置是点的话                    if (!lights.contains(i - 1) && !lights.contains(i) && !lights.contains(i + 1)) {                        return Integer.MAX_VALUE;                    }                }            }            return lights.size();        } else { // str还没结束            // i X .            int no = process(str, index + 1, lights);            int yes = Integer.MAX_VALUE;            if (str[index] == '.') {                lights.add(index);                yes = process(str, index + 1, lights);                lights.remove(index);            }            return Math.min(no, yes);        }    }    public static String generatorStringLength(int maxLength,int maxPoint){        int length = (int)(Math.random() * maxLength) + 1;        StringBuilder sb = new StringBuilder();        for (int i = 0; i < length; i++) {            if (Math.random() > 0.5){                sb.append("X");            }else {               int point = (int)(Math.random() * maxPoint) + 1;                sb.append(".".repeat(Math.max(0, point)));            }        }        return sb.toString();    }    public static void main(String[] args) {        int maxLength = 1000;        int maxPoint = 10;        int testCount = 100000;        System.out.println("Start......");        for (int i = 0; i < testCount; i++) {            String str = generatorStringLength(maxLength, maxPoint);            if (minLight_01(str) != minLight_02(str)){                System.out.println(str);                System.out.println(minLight_01(str) + " ===== "+  minLight_02(str));                System.out.println("Oops.....");            }        }        System.out.println("Finish.....");    }}