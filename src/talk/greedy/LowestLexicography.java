package talk.greedy;import java.util.*;/** * 贪心算法: 题目: 给定一个字符串组成的数组 strs,必须将所有的字符串拼接起来,返回所有可能的拼接过程中,字典序最小的顺序 * *      条件: 数组中的每个字符串不可改变其顺序,需要全部进行拼接 */public class LowestLexicography {    public static String lowestString_01(String[] strs){        if (strs == null || strs.length == 1) {            return Arrays.toString(strs);        }        TreeSet<String> process = process(strs);        return process.size() == 0 ? "" : process.first();    }    public static TreeSet<String> process(String[] strs) {        TreeSet<String> ans = new TreeSet<>();        if (strs.length == 0) {            ans.add("");            return ans;        }        for (int i = 0; i < strs.length; i++) {            String first = strs[i];            String[] nexts = removeIndexString(strs, i);            TreeSet<String> process = process(nexts);            for (String cur : process) {                ans.add(first + cur);            }        }        return ans;    }    private static String[] removeIndexString(String[] strs, int curIndex){        int length = strs.length;        String[] newStr = new String[length - 1];        int ansIndex = 0;        for (int i = 0; i < length; i++) {            if (i != curIndex){                newStr[ansIndex++] = strs[i];            }        }        return newStr;    }    /**     * 此处的贪心策略有以下几种:     *      1: 以字典序对每个独立的字符串进行排序,得到局部最优解     *          反例: [b,ba] 其中 b < ba  但是 bba > bab  --> 因此此策略失效     *     *      2: 根据 1 的反例,得到第二种贪心策略, 两字符拼接后的字典序大小     */    public static class StringComparator implements Comparator<String> {        @Override        public int compare(String a, String b) {            return (a + b).compareTo(b + a);        }    }    public static String lowestString_02(String[] strings){        if (strings == null || strings.length == 1){            return Arrays.toString(strings);        }        Arrays.sort(strings,new StringComparator());        StringBuilder sb = new StringBuilder();        for (String string : strings) {            sb.append(string);        }        return sb.toString();    }    // for test    public static String generateRandomString(int strLen) {        char[] ans = new char[(int) (Math.random() * strLen) + 1];        for (int i = 0; i < ans.length; i++) {            int value = (int) (Math.random() * 5);            ans[i] = (Math.random() <= 0.5) ? (char) (65 + value) : (char) (97 + value);        }        return String.valueOf(ans);    }    // for test    public static String[] generateRandomStringArray(int arrLen, int strLen) {        String[] ans = new String[(int) (Math.random() * arrLen) + 1];        for (int i = 0; i < ans.length; i++) {            ans[i] = generateRandomString(strLen);        }        return ans;    }    // for test    public static String[] copyStringArray(String[] arr) {        String[] ans = new String[arr.length];        for (int i = 0; i < ans.length; i++) {            ans[i] = String.valueOf(arr[i]);        }        return ans;    }    public static void main(String[] args) {        int arrLen = 6;        int strLen = 5;        int testTimes = 10000;        System.out.println("test begin");        for (int i = 0; i < testTimes; i++) {            String[] arr1 = generateRandomStringArray(arrLen, strLen);            String[] arr2 = copyStringArray(arr1);            if (!lowestString_01(arr1).equals(lowestString_02(arr2))) {                for (String str : arr1) {                    System.out.print(str + ",");                }                System.out.println();                System.out.println("Oops!");            }        }        System.out.println("finish!");    }}