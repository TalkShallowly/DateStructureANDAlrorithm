package talk.greedy;import java.util.PriorityQueue;/** * 题目: 一块金条切成两半,是需要花费和长度数值一样的铜板的, *        比如: 长度为 20 的金条,不管怎么切,都需要会费 20 个铜板,一群人想分整块金条,怎么分最省铜板 ? *          如果长度为 60 的金条需要三个人分, 分成[10,20,30]的长度, *              假设先将金条分为 10 和 50, 花费 60个铜板,在将长度 50 的部分 分为 20 和 30,花费 50,一共花费 110 个铜板; *              但是若先将金条分为 30 和 30,花费 60,在将长度 30 的部分 分为 10 和 20, 花费 30,一共花费 90 个铜板, *                  求: 输入一个数组,返回分割最小代价 * *              解: 贪心算法 --> 哈夫曼编码 */public class LessMoneySplitGold {    public static int lessMoneySplitGold(int[] spiltInts){        if (spiltInts == null || spiltInts.length == 0){            return 0;        }        //第二步: 将数组放入小根堆中 (默认小根堆,不需要指定比较器)        PriorityQueue<Integer> queue = new PriorityQueue<>();        for (int spiltInt : spiltInts) {            queue.add(spiltInt);        }        //第三步: 依次去堆中的数据进行相加后放入        int sum = 0;        //第一种循环        int cur = 0;        while (queue.size() > 1){            cur = queue.poll() + queue.poll();            sum += cur;            queue.add(cur);        }        //第二种循环//        while (!queue.isEmpty()){//            Integer first = queue.poll();//            if (queue.isEmpty()){//                return sum;//            }//            Integer second = queue.poll();//            int curNum = first + second;//            sum += curNum;//            if (queue.isEmpty()){//                return sum;//            }//            queue.add(curNum);//        }        return sum;    }    // 纯暴力！    public static int lessMoneySplitGoldCheck(int[] arr) {        if (arr == null || arr.length == 0) {            return 0;        }        return process(arr, 0);    }    // 等待合并的数都在arr里，pre之前的合并行为产生了多少总代价    // arr中只剩一个数字的时候，停止合并，返回最小的总代价    public static int process(int[] arr, int pre) {        if (arr.length == 1) {            return pre;        }        int ans = Integer.MAX_VALUE;        for (int i = 0; i < arr.length; i++) {            for (int j = i + 1; j < arr.length; j++) {                ans = Math.min(ans, process(copyAndMergeTwo(arr, i, j), pre + arr[i] + arr[j]));            }        }        return ans;    }    public static int[] copyAndMergeTwo(int[] arr, int i, int j) {        int[] ans = new int[arr.length - 1];        int ansi = 0;        for (int arri = 0; arri < arr.length; arri++) {            if (arri != i && arri != j) {                ans[ansi++] = arr[arri];            }        }        ans[ansi] = arr[i] + arr[j];        return ans;    }    public static int[] generateRandomArray(int maxLength,int maxValue){        int[] arr = new int[(int)(Math.random() * maxLength) + 1];        for (int i = 0; i < arr.length; i++) {            arr[i] = (int)(Math.random() * maxValue) + 1;        }        return arr;    }    public static void main(String[] args) {        int maxLength = 6;        int maxValue = 1000;        int testCount = 100000;        System.out.println("Start.....");        for (int i = 0; i < testCount; i++) {            int[] ints = generateRandomArray(maxLength, maxValue);            if (lessMoneySplitGold(ints) != lessMoneySplitGoldCheck(ints)){                System.out.println("Oops...");            }        }        System.out.println("Finish.....");    }}