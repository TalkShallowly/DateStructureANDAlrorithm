package talk.recursion_violence;import java.util.ArrayList;import java.util.List;/** * 问题: 打印一个字符串字节数据的全部排列 * * @author guojunshan * @date 2022/7/29 */public class PrintStringAllPermutations {    /**     * 打印一个字符串字节数据的全部排列     * @param str 测试字符串     * @return 排列字符     */    public static List<String> printPermutations(String str){        if (str == null || str.length() < 1){            return null;        }        char[] chars = str.toCharArray();        List<String> ans = new ArrayList<>();        process(chars,ans,"");        return ans;    }    private static void process(char[] chars, List<String> ans, String preRes){        if (chars.length < 1){            ans.add(preRes);            return;        }        for (int i = 0; i < chars.length; i++){            //在此处执行递归,注意点: 需要将数据中执行到当前的元素进行删除, 之后在以路径 + 当前字符实现现场的恢复            process(removeIndex(chars,i),ans,preRes + chars[i]);        }    }    public static List<String> printPermutationsNoRepeat(String str){        if (str == null || str.length() < 1){            return null;        }        char[] chars = str.toCharArray();        List<String> ans = new ArrayList<>();        process_o2(chars,ans,"");        return ans;    }    private static void process_o2(char[] chars, List<String> ans, String preRes){        if (chars.length < 1){            ans.add(preRes);            return;        }        //使用 256 个 ASCII 码值进行标识,        // 去重复数据,虽可以用 Hashset 解决,但是当时当数据量较大的时候,会走遍每条链路,之后在剔除        //此处使用 boolean[] 可以进行对已经排列过的字符做到标识,同时剔除当前链路        boolean[] visited = new boolean[256];        for (int i = 0; i < chars.length; i++){            if (!visited[chars[i]]){                visited[chars[i]] = true;                process_o2(removeIndex(chars,i),ans,preRes + chars[i]);            }        }    }    private static char[] removeIndex(char[] chars,int index){        char[] newChar = new char[chars.length - 1];        int help = 0;        for (int i = 0; i < chars.length; i++){            if (i != index){                newChar[help++] = chars[i];            }        }        return newChar;    }    public static void main(String[] args) {        String str = "ass";        printPermutationsNoRepeat(str).forEach(System.out::println);    }}