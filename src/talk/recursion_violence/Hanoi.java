package talk.recursion_violence;import java.util.Stack;/** * <pre> * 问题一: 汉诺塔问题 *        假设有三个圆盘,分为大中小,有三个柱子左中右,其中左边柱子上套着三个圆盘, 按大小顺序排列, 现在需要将左边柱子上的圆盘依次转换到右边柱子上, *            圆盘顺序不能改变 (每次只能移动一个圆盘),总共需要多少步,并显示其相应的步骤 ? ........有 n 个盘子如何处理 ? * *        解: 三个圆盘需要 7 步骤: *                1: 左 -> 右   2: 左 -> 中  3: 右 -> 中 *                4: 左 -> 右   5: 中 -> 左  6: 中 -> 右  7: 左 -> 右 *            多个圆盘可以依次嵌套 * *            简化: 整体 3 步骤 *                1: 将 1~n 从 左 -> 中 *                2: 将 0 从 左 -> 右 *                3: 将 中 -> 左 (从 步骤1 循环) * </pre> * * @author guojunshan * @date 2022/7/29 */public class Hanoi {    public static void hanoi_o1(int n) {        leftToRight(n);    }    private static void leftToRight(int n) {        if (n == 1){            System.out.println("move 1 from left to right");            return;        }        leftToMid(n - 1);        System.out.println("move " + n +  " mid left to right");        midToRight(n - 1);    }    private static void leftToMid(int n) {        if (n == 1){            System.out.println("move 1 from left to mid");            return;        }        leftToRight(n - 1);        System.out.println("move " + n +  " from right to mid");        rightToMid(n - 1);    }    private static void rightToMid(int n) {        if (n == 1){            System.out.println("move 1 from right to mid");            return;        }        rightToLeft(n - 1);        System.out.println("move " + n +  " from left to mid");        leftToMid(n - 1);    }    private static void rightToLeft(int n) {        if (n == 1){            System.out.println("move 1 from right to left");            return;        }        rightToMid(n - 1);        System.out.println("move " + n +  " from mid to left");        midToLeft(n - 1);    }    private static void midToLeft(int n) {        if (n == 1){            System.out.println("move 1 from mid to left");            return;        }        midToRight(n - 1);        System.out.println("move " + n +  " from right to left");        rightToLeft(n - 1);    }    private static void midToRight(int n) {        if (n == 1){            System.out.println("move 1 from mid to right");            return;        }        midToLeft(n - 1);        System.out.println("move " + n +  " from left to right");        leftToRight(n - 1);    }    /**     * 简化版本     * @param n 圆盘个数     */    public static void hanoi_o2(int n) {        if (n > 0){            func(n,"left","right","mid");        }    }    /**     * 简化: 整体 3 步骤     *  *                1: 将 1~n 从 左 -> 中     *  *                2: 将 0 从 左 -> 右     *  *                3: 将 中 -> 左 (从 步骤1 循环)     * @param n 圆盘个数     */    private static void func(int n, String from, String to, String other){        if (n == 1){            System.out.println("move 1 from " + from + " to " + to);        }else {            func(n - 1,from,other,to);            System.out.println("move " + n + " from " + from + " to " + to);            func(n - 1,other,to,from);        }    }    /**     * 使用一个基类记录传递的参数     */    public static class Record {        //是否完成        public boolean finish;        //当前剩余圆盘个数        public int base;        public String from;        public String to;        public String other;        public Record(boolean f1, int b, String f, String t, String o) {            finish = false;            base = b;            from = f;            to = t;            other = o;        }    }    /**     * 使用非递归方法实现     * @param N 圆盘个数     */    public static void hanoi3(int N) {        if (N < 1) {            return;        }        Stack<Record> stack = new Stack<>();        stack.add(new Record(false, N, "left", "right", "mid"));        while (!stack.isEmpty()) {            Record cur = stack.pop();            if (cur.base == 1) {                System.out.println("Move 1 from " + cur.from + " to " + cur.to);                //此处的作用在于,如果最后一个圆盘到达指定位置,则还有剩余的圆盘需要处理                if (!stack.isEmpty()) {                    stack.peek().finish = true;                }            } else {                //是否还有最后一个节点                if (!cur.finish) {                    stack.push(cur);                    stack.push(new Record(false, cur.base - 1, cur.from, cur.other, cur.to));                } else {                    //处理剩余的圆盘                    System.out.println("Move " + cur.base + " from " + cur.from + " to " + cur.to);                    stack.push(new Record(false, cur.base - 1, cur.other, cur.to, cur.from));                }            }        }    }    public static void main(String[] args) {        int n = 3;//        hanoi_o1(n);        hanoi_o2(3);    }}