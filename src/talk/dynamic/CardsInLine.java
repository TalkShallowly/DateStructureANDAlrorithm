package talk.dynamic;/** *<pre> * 暴力递归到动态规划: *      问题二: 给定一个整形数组 arr,其arr 代表数值不同的纸牌排成一条线, *              玩家 A和玩家 B 依次拿走每一个纸牌,规定 玩家 A 先拿玩家 B 后拿,但每次只能拿最坐左和最右的纸牌的玩家, *              假设玩家 a 和玩家 b智商一样,返回最后获胜者的分数 * </pre> * * @author guojunshan * @date 2022/8/8 */public class CardsInLine{    public static int winnerScore_recursion(int[] arr){        if (arr == null || arr.length == 0){            return 0;        }        return Math.max(player_A_01(arr,0,arr.length - 1), player_B_01(arr,0,arr.length - 1));    }    private static int player_A_01(int[] arr, int start, int end){        if (start == end){            return arr[start];        }        //玩家 A 选择当前最好一种方式,当前选择的数据和之后 玩家 B 获取数据最大化后的最小数        int p1 = arr[start] + player_B_01(arr,start + 1,end);        int p2 = arr[end] + player_B_01(arr,start,end - 1);        return Math.max(p1, p2);    }    private static int player_B_01(int[] arr, int start, int end){        //此处返回 0, 是因为在玩家 A 已经将纸牌拿走,        if (start == end){            return 0;        }        int p1 =  player_A_01(arr,start + 1,end);        int p2 =  player_A_01(arr,start,end - 1);        //此时大的数据已经被 A 所拿走,但是玩家 B 也在试图寻求数据最大化,所以返回两个结果的最小值        return Math.min(p1, p2);    }    public static int winnerScore_cache(int[] arr){        if (arr == null || arr.length == 0){            return 0;        }        int N = arr.length;        int[][] dpA = new int[N][N];        int[][] dpB = new int[N][N];        for (int i = 0; i < N; i++) {            for (int j = 0; j < N; j++) {                dpA[i][j] = -1;                dpB[i][j] = -1;            }        }        return Math.max(player_A_02(arr,0,arr.length - 1,dpA,dpB), player_B_02(arr,0,arr.length - 1,dpB,dpA));    }    private static int player_A_02(int[] arr, int start, int end,int[][] dpA,int[][] dpB){        if (dpA[start][end] != -1){            return dpA[start][end];        }        //玩家 A 选择当前最好一种方式,当前选择的数据和之后 玩家 B 获取数据最大化后的最小数        int res = start == end ? arr[start] : Math.max(arr[start] + player_B_02(arr,start + 1,end,dpB,dpA), arr[end] + player_B_02(arr,start,end - 1,dpB,dpA));        dpA[start][end] = res;        return res;    }    private static int player_B_02(int[] arr, int start, int end, int[][] dpB,int[][] dpA) {        //此处返回 0, 是因为在玩家 A 已经将纸牌拿走,        //此时大的数据已经被 A 所拿走,但是玩家 B 也在试图寻求数据最大化,所以返回两个结果的最小值        if (dpB[start][end] != -1) {            return dpB[start][end];        }        int res = start == end ? 0 : Math.min(player_A_02(arr, start + 1, end, dpA, dpB), player_A_02(arr, start, end - 1, dpA, dpB));        dpB[start][end] = res;        return res;    }    public static int winnerScore_dynamic(int[] arr){        if (arr == null || arr.length == 0){            return 0;        }        int N = arr.length;        int[][] dpA = new int[N][N];        int[][] dpB = new int[N][N];        //初始化 A 表数据        for (int i = 0; i < N; i++) {           dpA[i][i] = arr[i];        }        //根据递归分析二维缓存表依赖, A 和 B 相互对角线依赖 (填充对角数据)        for (int col = 1; col < N; col++) {            int row = 0;            int startCol = col;            while (startCol < N){                dpB[row][startCol] = Math.max(arr[row] + dpA[row][startCol - 1], arr[row] + dpA[row + 1][startCol]);                dpA[row][startCol] = Math.min(dpB[row][startCol - 1], dpB[row + 1][startCol]);                row++;                startCol++;            }        }        return Math.max(dpA[0][N - 1],dpB[0][N - 1]);    }    public static void main(String[] args) {        int[] arr = {2,4,5,7};        System.out.println(winnerScore_recursion(arr));        System.out.println(winnerScore_cache(arr));        System.out.println(winnerScore_dynamic(arr));    }}