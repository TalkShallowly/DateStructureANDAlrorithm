package talk.dynamic;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * 问题: *      arr[] 是货币数组, 其中的值都是正数, 在给定一个正数 aim, 每个值都认为是一张货币 *          认为值相同的货币, 没有任何不同, 求返回组成 aim 的方法数 * *            eg : arr[1,2,1,1,2,1,2]   aim = 4 *               1,1,1,1   1,1,2  2,2 共有 3 中方法 * *           动态规划优化: *              严格位置依赖 --- (针对枚举策略时) *                 空间压缩 (节省空间, 但时间复杂度不变) * * * * @author guojunshan * @date 2022/10/1 */public class CoinsWaySameValueSamePaper {    static class Info{        private final int[] target;        private final int[] num;        Info(int[] _target, int[] _num) {            this.target = _target;            this.num = _num;        }    }    public static int coinsWay(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        Info info = getInfo(arr);        return process(info,0,aim);    }    public static Info getInfo(int[] arr){        Map<Integer, Integer> map = new HashMap<>();        for (int j : arr) {            if (map.containsKey(j)) {                map.put(j, map.get(j) + 1);            } else {                map.put(j, 1);            }        }        int N = map.size();        int[] target = new int[N];        int[] num = new int[N];        int i = 0;        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {            target[i] = entry.getKey();            num[i] = entry.getValue();            i++;        }        return new Info(target, num);    }    public static int  process(Info info, int index, int rest){        if (rest < 0){            return 0;        }        int[] target = info.target;        int[] num = info.num;        if (index == target.length){            return rest == 0 ? 1 : 0;        }        int way = 0;        for (int i = 0; i <= num[index]; i++) {            way +=process(info, index + 1,rest - (i * target[index]));        }        return way;    }    public static int  dp1(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        Info info = getInfo(arr);        int[] target = info.target;        int[] num = info.num;        int N = target.length;        int[][] dp = new int[N + 1][aim + 1];        dp[N][0] = 1;        for (int index = N - 1; index >= 0; index--) {            for (int rest = 0; rest <= aim; rest++){                int way = 0;                for (int i = 0; i <= num[index]; i++) {                    way += rest - (i * target[index]) < 0 ? 0 : dp[index + 1][rest - (i * target[index])];                }                dp[index][rest] = way;            }        }        return dp[0][aim];    }    public static int  dp2(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        Info info = getInfo(arr);        int[] target = info.target;        int[] num = info.num;        int N = target.length;        int[][] dp = new int[N + 1][aim + 1];        dp[N][0] = 1;        for (int index = N - 1; index >= 0; index--) {            for (int rest = 0; rest <= aim; rest++){                dp[index][rest] = rest < target[index] ? dp[index + 1][rest] : dp[index + 1][rest] +  dp[index][rest - target[index]];                //在当前剩余金额超过当前面值总金额时, 会多加一证该面值的金额                if (rest - (target[index] * (num[index] + 1)) >= 0){                    dp[index][rest] -= dp[index + 1][rest - (target[index] * (num[index] + 1))];                }            }        }        return dp[0][aim];    }    public static int[] generateRandomArray(int maxLen, int maxValue){        int len = (int)(Math.random() * maxLen) + 1;        int[] arr = new int[len];        for (int i = 0; i < len; i++) {            arr[i] = (int) (Math.random() * maxValue) + 1;        }        return arr;    }    public static void printArray(int[] arr){        System.out.println(Arrays.toString(arr));    }    public static void main(String[] args) {        int maxLen = 50;        int maxValue = 100;        int testTimes = 1000;        System.out.println("测试开始");        for (int i = 0; i < testTimes; i++) {            int[] ints = generateRandomArray(maxLen, maxValue);            int aim = (int)(Math.random() * maxValue) + 1;            int coinsWay = coinsWay(ints, aim);            int dp1 = dp1(ints, aim);            int dp2 = dp2(ints, aim);            if (coinsWay != dp1 || coinsWay != dp2){                System.out.println("coinsWay = " + coinsWay + "  :  dp2 = " + dp2 + "  :  dp1 = " + dp1 + " :  aim = "  + aim);                printArray(ints);                System.out.println("oops");                return;            }        }        System.out.println("测试结束");    }}