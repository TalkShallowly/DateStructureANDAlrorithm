package talk.dynamic;/** * 动态规划: *     问题: *          一个棋盘象棋的棋盘,然后将整个棋盘对应第一象限,棋盘的最左下角为(0,0)位置, *              那么整个棋盘就是横坐标上 9 条线,纵坐标上 10 条线的区域, 给定三个参数(x,y,k) *                  返回 "马" 从(0,0)位置出发, 经过 K 步,最终回到(x,y)位置的方法种数 * @author guojunshan * @date 2022/9/19 */public class HorseJump {    public static int horse(int x, int y, int k){        if (x < 0 || x > 8 || y < 0 || y > 9 || k < 0){            return 0;        }        return process(0,0,x , y, k);    }    /**     * 递归逻辑     * @param cur_x 当前来到的 x 位置     * @param cur_y 当前来到的 y 位置     * @param x 给定的 x 位置     * @param y 给定的 y 位置     * @param rest 当前位置 到达 剩余位置的剩余步数     * @return 方法种树     */    public static int process(int cur_x, int cur_y , int x, int y, int rest){        if (cur_x < 0 || cur_x > 8 || cur_y < 0 || cur_y > 9){            return 0;        }        if (rest == 0){            return cur_x == x && cur_y == y ? 1 : 0;        }        /*            可能性分析 :                在棋盘上没一点对应 8 个跳点         */        int was = process(cur_x + 1, cur_y + 2, x, y ,rest - 1);        was += process(cur_x + 2, cur_y + 1, x, y ,rest - 1);        was += process(cur_x + 1, cur_y - 2, x, y ,rest - 1);        was += process(cur_x + 2, cur_y - 1, x, y ,rest - 1);        was += process(cur_x - 1, cur_y - 2, x, y ,rest - 1);        was += process(cur_x - 2, cur_y - 1, x, y ,rest - 1);        was += process(cur_x - 1, cur_y + 2, x, y ,rest - 1);        was += process(cur_x - 2, cur_y + 1, x, y ,rest - 1);        return was;    }    public static int horse_dynamic(int a, int b, int k){        if (a < 0 || a > 8 || b < 0 || b > 9 || k < 0){            return 0;        }        //给定一个棋盘的限定结构        int[][][] dp = new int[9][10][k + 1];        //填充底层数据        dp[a][b][0] = 1;        //冲最低层依次向上填充        for (int i = 1; i <= k; i++) {            for (int x = 0; x < 9; x++) {                for (int y = 0; y < 10; y++) {                    dp[x][y][i] = pick(dp,x + 2,y + 1, i - 1)                            + pick(dp,x + 1,y + 2, i - 1)                            + pick(dp,x + 1,y - 2, i - 1)                            + pick(dp,x + 2,y - 1, i - 1)                            + pick(dp,x - 2,y + 1, i - 1)                            + pick(dp,x - 2,y - 1, i - 1)                            + pick(dp,x - 1,y + 2, i - 1)                            + pick(dp,x - 1,y - 2, i - 1);                }            }        }        return dp[0][0][k];    }    /**     * 三维边数据限定函数     * @param dp 数据表     * @param x  x 位置     * @param y  y 位置     * @param k  k     * @return dp[x][y][k]     */    private static int pick(int[][][] dp, int x ,int y ,int k){        if (x < 0 || x > 8 || y < 0 || y > 9 || k < 0){            return 0;        }        return dp[x][y][k];    }    public static void main(String[] args) {        int x = 8;        int y = 8;        int step = 12;        long start = System.currentTimeMillis();        System.out.println(horse_dynamic(x, y, step));        long mid = System.currentTimeMillis();        System.out.println(horse(x, y, step));        long end = System.currentTimeMillis();        System.out.println(" dynamic : " +  (mid - start) + "   recursion : " + (end - mid));    }}