package talk.dynamic;/** * 暴力递归到动态规划: *  问题四: *      规定 1 和 A 对应, 2 和 B 对应, 3 和 C 对应........ 26 和 Z 对应, *      那么就可以根据其对应的关系,将一串数组转为字符串, *          eg: 111 --> AAA / KA / AK 三种方式 *     给定一串数字,求返回最共有多少种转换结果? * * @author guojunshan * @date 2022/8/9 */public class ConvertToLetterString {    /**     * str 只包含数字     */    public static int convert(String str){        if (str == null || str.length() == 0){            return 0;        }        return process( str.toCharArray(), 0);    }    /**     * 策略: 使得 chars[0][i] 上有多少种转换方式     * @param str str 数组     * @param i 当前位置     * @return  种转换方式种类     */    private static int process(char[] str, int i){        if (i == str.length){            return 1;        }        if (str[i] == '0'){            return 0;        }        int way = process(str, i + 1);//        (str[i] - '0') * 10 + str[i + 1] - '0' < 27        if (i + 1 < str.length && ((str[i] - '0') * 10 + (str[i + 1]) - '0') < 27){            way += process(str, i + 2);        }        return way;    }    public static String randomString(int length){        StringBuilder sb = new StringBuilder();        for (int i = 0; i < length; i++) {            sb.append((int) (Math.random() * 10));        }        return sb.toString();    }    public static void main(String[] args) {        int testTime = 10;        System.out.println("Start.......");        for (int i = 0; i < testTime; i++) {            String str = randomString(5);            if (test(str) != convert(str)){                System.out.println("test: " + test(str)  + "  actual: " + convert(str));                System.out.println(str);            }        }        System.out.println("End.........");    }    public static int test(String s) {        if (s == null || s.length() == 0) {            return 0;        }        char[] str = s.toCharArray();        int N = str.length;        if (str[0] == '0') {            return 0;        }        int[] dp = new int[N];        dp[0] = 1;        for (int i = 1; i < N; i++) {            if (str[i] == '0') {                // 如果此时str[i]=='0'，那么他是一定要拉前一个字符(i-1的字符)一起拼的，                // 那么就要求前一个字符，不能也是‘0’，否则拼不了。                // 前一个字符不是‘0’就够了嘛？不够，还得要求拼完了要么是10，要么是20，如果更大的话，拼不了。                // 这就够了嘛？还不够，你们拼完了，还得要求str[0...i-2]真的可以被分解！                // 如果str[0...i-2]都不存在分解方案，那i和i-1拼成了也不行，因为之前的搞定不了。                if (str[i - 1] == '0' || str[i - 1] > '2' || (i - 2 >= 0 && dp[i - 2] == 0)) {                    return 0;                } else {                    dp[i] = i - 2 >= 0 ? dp[i - 2] : 1;                }            } else {                dp[i] = dp[i - 1];                if (str[i - 1] != '0' && (str[i - 1] - '0') * 10 + str[i] - '0' <= 26) {                    dp[i] += i - 2 >= 0 ? dp[i - 2] : 1;                }            }        }        return dp[N - 1];    }}