package talk.dynamic;/** * 问题: *   给定 3 个参数 N, M, K *      怪兽有 N 滴血, 等着英雄来砍自己, 英雄的每一此打击, 都会让怪兽消失 [0 ~ M] 的血量, *      (在 [0 ~ M] 上等概率获取一个数值), 求 K 次打击之后, 英雄将怪兽砍死的概率 * * *      下面的 dp 表以怪兽的血量为行, 打击次数为列 * *      多元化: 实现以打击次数为行, 以怪兽血量为列 * * * @author guojunshan * @date 2022/10/2 */public class KillMonster {    public static double beatMonster(int N, int M, int K) {        if (N < 1 || M < 1 || K < 1) {            return 0;        }        //每一次砍击, 他的概率为 M + 1 总概率为 (M - 1) ^ K        long all = (long) Math.pow(M + 1, K);        return (double) process(M, N, K) / all;    }    /**     * 在 K 次之内将怪兽打死的次数     *     * @param M         打击范围     * @param restBlood 剩余血量     * @param restBeat  剩余打击次数     * @return 打死的次数     */    private static long process(int M, int restBlood, int restBeat) {        //当打击次数为 0 的时候, 而且对于怪兽血量如果 <= 0, 那么则返回 1        if (restBeat == 0) {            return restBlood <= 0 ? 1 : 0;        }        //因为怪兽血量已经 <=0 , 那么接下来剩余的打击次数, 都会是每一次的全概率相加        if (restBlood <= 0){            return (long) Math.pow((M + 1),restBeat);        }        long way = 0;        for (int i = 0; i <= M; i++) {            way += process(M, restBlood - i, restBeat - 1);        }        return way;    }    public static double dp1(int N, int M, int K) {        if (N < 1 || M < 1 || K < 1) {            return 0;        }        long all = (long) Math.pow(M + 1, K);        int[][] dp = new int[N + 1][K + 1];        dp[0][0] = 1;        for (int row = 0; row <= N; row++) {            for (int col = 1; col <= K; col++) {                for (int i = 0; i <= M; i++) {                    if (row - i >= 0) {                        dp[row][col] += dp[row - i][col - 1];                    } else {                        dp[row][col] += (long) Math.pow(M + 1, col - 1);                    }                }            }        }        return (double) dp[N][K] / all;    }    public static double dp2(int N, int M, int K) {        if (N < 1 || M < 1 || K < 1) {            return 0;        }        long all = (long) Math.pow(M + 1, K);        long[][] dp = new long[N + 1][K + 1];        dp[0][0] = 1;        //填充第 0 行的数据 --- 或者可以在下面的循环中填写//        for (int col = 1; col <= K; col++) {//            dp[0][col] = dp[0][col - 1] + (long) Math.pow(M + 1, col - 1) * M;//        }        for (int row = 1; row <= N; row++) {            for (int col = 1; col <= K; col++) {                // 严格位置依赖 (以怪兽血量为行, 打次次数为列)                dp[0][col] = dp[0][col - 1] + (long) Math.pow(M + 1, col - 1) * M;                dp[row][col] = dp[row][col - 1] + dp[row - 1][col];                if (row - M - 1>= 0) {                    dp[row][col] -= dp[row - M - 1][col - 1];                }else {                    dp[row][col] -= (long) Math.pow(M + 1, col - 1);                }            }        }        System.out.println(dp[N][K]);        return (double) dp[N][K] / all;    }    public static void main(String[] args) {        double v = beatMonster(10, 5, 5);        double dp1 = dp1(10, 5, 5);        double dp2 = dp2(10, 5, 5);        System.out.println(v);        System.out.println(dp1);        System.out.println(dp2);    }//    public static void main(String[] args) {//        int NMax = 10;//        int MMax = 10;//        int KMax = 10;//        int testTime = 200;//        System.out.println("测试开始");//        for (int i = 0; i < testTime; i++) {//            int N = (int) (Math.random() * NMax);//            int M = (int) (Math.random() * MMax);//            int K = (int) (Math.random() * KMax);//            double ans1 = beatMonster(N, M, K);//            double ans3 = dp2(N, M, K);//            if (ans1 != ans3) {//                System.out.println(" N = " + N + " --- M = " + M + " --- K = " + K);//                System.out.println(ans1);//                System.out.println(ans3);//                System.out.println("Oops!");//                break;//            }//        }//        System.out.println("测试结束");//    }}