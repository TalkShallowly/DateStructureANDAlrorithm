package talk.dynamic;/** * 暴力递归到动态归还: *  问题三: *      背包问题: 有两个数组等长, 其中存放着商品的重量和价格, 规定一个背包的容量, 在不超过指定容量 (即重量) 的情况下,返回最大价格 * * @author guojunshan * @date 2022/8/9 */public class Knapsack {    /**     * 暴力递归     * @param weights 商品重量     * @param prices 商品价格     * @param capacity 背包容量     * @return 最大价格数     */    public static int maxPrice_01(int[] weights, int[] prices, int capacity){        if (weights == null || prices == null || prices.length != weights.length ||  capacity < 0){            return 0;        }        return process(weights,prices,capacity,0);    }    /**     * 返回当前价格     * @param weights 商品重量     * @param prices 商品价格     * @param restCap 背包剩余容量     * @param index 当前来到位置     * @return 当前最大价格     */    private static int process(int[] weights, int[] prices, int restCap, int index){        if (restCap < 0){            return -1;        }        if (index == weights.length){            return 0;        }        //不需要当前索引位置的商品        int p2 = process(weights,prices,restCap,index + 1);        //需要当前索引位置的商品        int next = process(weights,prices,restCap - weights[index],index + 1);        //需要的下面商品是否有效,如果无效则当前背包容量已经超出        int p1 = next != -1 ? next + prices[index] : 0;        return Math.max(p1,p2);    }    /**     * 暴力递归 + 傻缓存     * @param weights 商品重量     * @param prices 商品价格     * @param capacity 背包容量     * @return 最大价格数     */    public static int maxPrice_02(int[] weights, int[] prices, int capacity){        if (weights == null || prices == null || prices.length != weights.length ||  capacity < 0){            return 0;        }        int N = weights.length;        int[][] dp = new int[N + 1][capacity + 1];        for (int i = 0; i <= N; i++) {            for (int j = 0; j <= capacity; j++) {                dp[i][j] = -1;            }        }        return  process_02(weights,prices,capacity,0,dp);    }    /**     * 返回当前价格     * @param weights 商品重量     * @param prices 商品价格     * @param restCap 背包剩余容量     * @param index 当前来到位置     * @return 当前最大价格     */    private static int process_02(int[] weights, int[] prices, int restCap, int index, int[][] dp){        if (restCap < 0){            return -1;        }        if (dp[index][restCap] != -1){            return dp[index][restCap];        }        int res = 0;        if (index != weights.length){            //不需要当前索引位置的商品            int p2 = process_02(weights,prices,restCap,index + 1,dp);            //需要当前索引位置的商品            int next = process_02(weights,prices,restCap - weights[index],index + 1,dp);            //需要的下面商品是否有效,如果无效则当前背包容量已经超出            int p1 = next != -1 ? next + prices[index] : 0;            res = Math.max(p1,p2);        }        dp[index][restCap] = res;        return res;    }    public static int maxPrice_03(int[] weights, int[] prices, int capacity){        if (weights == null || prices == null || prices.length != weights.length ||  capacity < 0){            return 0;        }        int N = weights.length;        int[][] dp = new int[N + 1][capacity + 1];        for (int index = N - 1; index >= 0; index--) {            for (int rest = 0; rest <= capacity; rest++) {                //不需要当前索引位置的商品                int p2 = dp[index + 1][rest];                //需要当前索引位置的商品                int next = rest - weights[index] < 0 ? -1 : dp[index + 1][rest - weights[index]];                //需要的下面商品是否有效,如果无效则当前背包容量已经超出                int p1 = next != -1 ? next + prices[index] : 0;                dp[index][rest] = Math.max(p1,p2);            }        }        for (int[] ints : dp) {            for (int anInt : ints) {                System.out.print(anInt + "\t");            }            System.out.println();        }        return dp[0][capacity];    }    public static void main(String[] args) {        int[] weight = {2,3,1,4};        int[] price = {20,30,10,60};        int capacity = 5;        System.out.println(maxPrice_01(weight, price, capacity));        System.out.println(maxPrice_02(weight, price, capacity));        System.out.println(maxPrice_03(weight,price,capacity));    }}