package talk.dynamic;/** * 问题: *      给定一个二维数组 matrix, 假设一个人必须从该矩阵的左上角出发, 最后到达右下角沿途只可以 *          向下或者向右走, 沿途的数字都累加就是距离的累加和, 求返回最小距离的累加和 * *          要求: 使用动态规划求解 *              优化一: 将二维表改为两数组的互推 *              优化二: 将两数组的互推, 优化为一个数组的互推 * *          技能点: 空间压缩技巧 *              对于 dp 表中依赖与两个相为邻的方向 (向右 -- 向下等) 如果可以确定某一边界 行或列 的全部数据, 则可以使用 单数据进行对应的空间压缩 * * * @author guojunshan * @date 2022/10/2 */public class MinPathSum {    /**     * 使用同矩阵的数据填充     */    public static int minPathSum(int[][] matrix){        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){            return 0;        }        int row = matrix.length;        int col = matrix[0].length;        int[][] dp = new int[row][col];        //填充第一行        dp[0][0] = matrix[0][0];        for (int i = 1; i < col; i++) {            dp[0][i] = matrix[0][i] + dp[0][i - 1];        }        //填充第一列        for (int i = 1; i < row; i++) {            dp[i][0] = matrix[i][0] + dp[i - 1][0];        }        //填充剩余空格        for (int i = 1; i < row; i++){            for (int j = 1; j < col; j++) {                dp[i][j] = Math.min(dp[i - 1][j],dp[i][j - 1]) + matrix[i][j];            }        }        return dp[row - 1][col - 1];    }    /**     * 优化一 ; 将二维数据表 改为两个数组的相互推理     */    public static int minPathSum1(int[][] matrix){        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){            return 0;        }        int row = matrix.length;        int col = matrix[0].length;        //辅助数组        int[] help = new int[col];        //结果数组        int[] res = new int[col];        //填充辅助数组        help[0] = matrix[0][0];        for (int i = 1; i < col; i++) {            help[i] = help[i - 1] + matrix[0][i];        }        //填充结果数组 (两个数组相互替换)        for (int i = 1; i < row; i++) {            res[0] = help[0] + matrix[i][0];            for (int j = 1; j < col; j++) {                res[j] = Math.min(res[j - 1],help[j]) + matrix[i][j];                //在上一行代码中 help[j]的数据已被使用, 因此在此处将 help[j] 替换, 准备下一次循环                help[j] = res[j];            }            help[0] = res[0];        }        return help[col - 1];    }    /**     * 优化二 : 使用一个数据的推理     */    public static int minPathSum2(int[][] matrix){        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){            return 0;        }        int row = matrix.length;        int col = matrix[0].length;        //结果数组        int[] res = new int[col];        //填充第一行        res[0] = matrix[0][0];        for (int i = 1; i < col; i++) {            res[i] = res[i - 1] + matrix[0][i];        }        //填充结果数组 (两个数组相互替换)        for (int i = 1; i < row; i++) {            res[0] += matrix[i][0];            for (int j = 1; j < col; j++) {                res[j] = Math.min(res[j - 1],res[j]) + matrix[i][j];            }        }        return res[col - 1];    }    public static int[][] generateMatrix(int length, int maxValue) {        int rows = (int)(Math.random() * length) + 1;        int cols = (int)(Math.random() * length) + 1;        int[][] matrix = new int[rows][cols];        for (int i = 0; i < rows; i++) {            for (int j = 0; j < cols; j++) {                matrix[i][j] = (int)(Math.random() * maxValue) + 1;            }        }        return matrix;    }    public static void main(String[] args) {//        int[][] matrix = {{1,1,3,4},{5,1,1,1},{2,1,4,1},{2,1,2,1}};        int length = 100;        int maxValue = 1000;        int testTimes = 1000;        System.out.println("测试开始!");        for (int i = 0; i < testTimes; i++) {            int[][] ints = generateMatrix(length, maxValue);            int dp = minPathSum(ints);            int dp1 = minPathSum1(ints);            int dp2 = minPathSum2(ints);            if (dp != dp2 || dp1 != dp2){                System.out.println("oops");                System.out.println("dp : " + dp + " --- dp1 : " + dp1 + " --- dp2 : " + dp2);                return;            }        }        System.out.println("测试结束!");    }}