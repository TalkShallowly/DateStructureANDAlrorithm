package talk.dynamic;/** * N 皇后问题: *      在一个 N * N 的棋盘上要摆 N 个皇后, 要求任何两个皇后不同行, 不同列, 也不再同一条斜线上, *          给定一个整数 N, 皇后的摆法有多少种? * *          eg: n = 1, 返回 1 *              n = 2, 返回 0 *              n = 3, 返回 0 *              ..... *              n = 8, 返回 92 * * @author guojunshan * @date 2022/10/8 */public class NQueens {    public static int queens(int N){        //排除无效解        if (N < 1){            return 0;        }        //记录数组, 用于记录每一行的皇后放在 那一列上 (数组下表为行号, 对应的值为放入皇后的列)        int[] record = new int[N];        return process(N,0 , record);    }    /**     *     * @param N 当前放入皇后的矩阵长度     * @param row 当前需要在哪一行放皇后     * @param record 记录数组, 记录之前列上的皇后     * @return 可放皇后的种类     */    private static int process(int N, int row, int[] record) {        //如果到达最后一行, 则有一种摆放方式        if (row == N) {            return 1;        }        int res = 0;        //尝试每一列        for (int col = 0; col < N; col++) {            if (isValid(record, row, col)) {                record[row] = col;                res += process(N, row + 1, record);            }        }        return res;    }    private static boolean isValid(int[] record, int row, int col){        for (int i = 0; i < row; i++) {            //对角线的判断, 行行之间的间距 != 列列之间的距离//            Math.abs(record[i] - col) == Math.abs(row - i)            if (col == record[i] || Math.abs(record[i] - col) == Math.abs(row - i)){                return false;            }        }        return true;    }    /**     * 使用位运算方式实现, 由于使用 int 类型,所以 N 不可超过 32 长度     */    public static int queens2(int N){        //排除无效解,        if (N < 1 || N >= 32){            return 0;        }        //将 N 用位置 11111 代替        int limit = (1 << N) - 1;        return process2(limit,0 , 0,0);    }    public static int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim) {        //当每一列都放完后,找到一种方式        if (colLim == limit) {            return 1;        }        /*          获取可以放皇后的位置:            第一步: colLim | leftDiaLim | rightDiaLim 将 列/左/右 限制取合集            第二步: 对合集取反, 则没有限制的位置为 1            第三步: limit & 取反合集, 则得到为 1 位置的即可为可放皇后的位置         */        int pos = limit & (~ ( colLim | leftDiaLim | rightDiaLim));        int mostRightOne = 0;        int res = 0;        while (pos != 0) {            //取出 pos 中最右边的 1            mostRightOne = pos & (~pos + 1);            //从 pos 中去除当前位置的            pos = pos - mostRightOne;            /*                colLim | mostRightOne 在限制类中加入当前列的标记                (leftDiaLim | mostRightOne) << 1 左限制中加入标记后整体向左移动以为 (左对角线限制)                (rightDiaLim | mostRightOne) >>> 1 右限制中加入标记后整体向右移动以为 (右对角线限制)             */            res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) << 1,                    (rightDiaLim | mostRightOne) >>> 1);        }        return res;    }    public static void main(String[] args) {        long start = System.currentTimeMillis();        System.out.println(queens(15));        long end = System.currentTimeMillis();        System.out.println(queens2(15));        long end2 = System.currentTimeMillis();        System.out.println("递归寻常遍历时间 : " + (end - start));        System.out.println("递归位运算遍历时间 : " + (end2 - end));    }}