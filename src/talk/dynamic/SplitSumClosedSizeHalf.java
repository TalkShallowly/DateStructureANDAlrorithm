package talk.dynamic;import java.util.Arrays;/** * 问题: *      给定一个正数数组 arr[] , 请将 arr[]中的所有的数分为两个集合, *          如果 arr[] 长度为偶数, 两个集合包含的个数一样多, *          如果 arr[] 长度为奇数, 两个集合中包含的个数必须差一个, *          请尽量让两个集合的累加和接近返回: 最接近的情况下 返回较小集合的累加和 * *          动态规划: 从左向右的尝试模型 * * * @author guojunshan * @date 2022/10/8 */public class SplitSumClosedSizeHalf {    public static int spiltArrSum(int[] arr){        if (arr == null || arr.length == 0) {            return 0;        }        //首先,需要计算源数组的累加和 (当分割为两个集合的累计和最接近的时候, 较小集合的累加和一定 <= sum / 2)        int sum = 0;        for (int j : arr) {            sum += j;        }        if ((arr.length & 1) == 0){            //偶数            return process(arr, 0, arr.length / 2, sum / 2);        }else {            //奇数            return Math.max(process(arr, 0, arr.length / 2, sum / 2), process(arr, 0, arr.length / 2 + 1, sum / 2));        }    }    private static int process(int[] arr, int index, int lenLimit, int sumLimit) {        //限制条件, 必须使 lenLimit 减少到 0, 不让做特殊处理        if (index == arr.length) {            return lenLimit == 0 ? 0 : -1;        }        //不需要当前数据        int p1 = process(arr, index + 1, lenLimit, sumLimit);        int p2 = -1;        if (arr[index] <= sumLimit) {            //需要当前数据 (当前数据如果 为 -1 , 那么数组不可能拼凑出一个长度为 lenLimit 的集合)            p2 = process(arr, index + 1, lenLimit - 1, sumLimit - arr[index]);        }        //当 上面执行结果 不是 -1 时, 那么就属于在其中有挑选出 长度 为 lenLimit 的集合        if (p2 != -1) {            p2 += arr[index];        }        return Math.max(p1, p2);    }    public static int dp(int[] arr){        if (arr == null || arr.length == 0) {            return 0;        }        //首先,需要计算源数组的累加和 (当分割为两个集合的累计和最接近的时候, 较小集合的累加和一定 <= sum / 2)        int sum = 0;        for (int j : arr) {            sum += j;        }        int N = arr.length;        sum = sum / 2;        int K = (arr.length + 1) / 2;        int[][][] dp = new int[N + 1][K + 1][sum + 1];        //初始化过程        for (int z = 0; z <= sum; z++) {            for (int x = 0; x <= N; x++) {                for (int y = 0; y <= K; y++) {                    dp[x][y][z] = -1;                }            }        }        for (int i = 0; i <= sum; i++) {            dp[N][0][i] = 0;        }        for (int z = 0; z <= sum; z++) {            for (int x = N - 1; x >= 0; x--) {                for (int y = 0; y <= K; y++) {                    int p1 = dp[x + 1][y][z];                    int p2 = -1;                    if (arr[x] <= z && y - 1 >= 0) {                        //需要当前数据 (当前数据如果 为 -1 , 那么数组不可能拼凑出一个长度为 lenLimit 的集合)                        p2 = dp[x + 1][y - 1][z - arr[x]];                    }                    //当 上面执行结果 不是 -1 时, 那么就属于在其中有挑选出 长度 为 lenLimit 的集合                    if (p2 != -1) {                        p2 += arr[x];                    }                    dp[x][y][z] = Math.max(p1, p2);                }            }        }        return (N & 1) == 0 ? dp[0][N / 2][sum] : Math.max(dp[0][N / 2][sum], dp[0][N / 2 + 1][sum]);    }    private static int[] generateRandomArray(int maxLen, int maxValue){        int len = (int) (Math.random() * maxLen) + 1;        int[] ints = new int[len];        for (int i = 0; i < len; i++) {            ints[i] = (int) (Math.random() * maxValue) + 1;        }        return ints;    }    private static void printArray(int[] arr){        System.out.println(Arrays.toString(arr));    }    public static void main(String[] args) {        int maxLen = 10;        int maxValue = 100;        int testCount = 1000;        System.out.println("测试开始!");        for (int i = 0; i < testCount; i++) {            int[] ints = generateRandomArray(maxLen, maxValue);            int spiltArrSum = spiltArrSum(ints);            int dp = dp(ints);            int test = test(ints);            if (spiltArrSum != test || spiltArrSum != dp){                printArray(ints);                System.out.println(" spiltArrSum : " + spiltArrSum + " --- dp : " + dp);                System.out.println("Oops");                return;            }        }        System.out.println("测试结束!");    }    public static int test(int[] arr) {        if (arr == null || arr.length < 2) {            return 0;        }        int sum = 0;        for (int num : arr) {            sum += num;        }        sum >>= 1;        int N = arr.length;        int M = (arr.length + 1) >> 1;        int[][][] dp = new int[N][M + 1][sum + 1];        for (int i = 0; i < N; i++) {            for (int j = 0; j <= M; j++) {                for (int k = 0; k <= sum; k++) {                    dp[i][j][k] = Integer.MIN_VALUE;                }            }        }        for (int i = 0; i < N; i++) {            for (int k = 0; k <= sum; k++) {                dp[i][0][k] = 0;            }        }        for (int k = 0; k <= sum; k++) {            dp[0][1][k] = arr[0] <= k ? arr[0] : Integer.MIN_VALUE;        }        for (int i = 1; i < N; i++) {            for (int j = 1; j <= Math.min(i + 1, M); j++) {                for (int k = 0; k <= sum; k++) {                    dp[i][j][k] = dp[i - 1][j][k];                    if (k - arr[i] >= 0) {                        dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - 1][k - arr[i]] + arr[i]);                    }                }            }        }        return Math.max(dp[N - 1][M][sum], dp[N - 1][N - M][sum]);    }}