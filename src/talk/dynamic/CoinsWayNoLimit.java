package talk.dynamic;import java.util.Arrays;/** * 问题: *      arr[]是面值数组, 其中的值都是正数且没有重复, 在给定一个正数 aim, 每个值都可以认为是一种面值, *          且认为张数树无线的 ,求返回组成 aim 的方法数; * * *              eg: arr[1,2]   aim = 4    返回结果 2 * *      动态规划模型: 从左向右的尝试模型 *          优化点: 建立空间数据 -- 观察尝试严格位置表依赖 * * @author guojunshan * @date 2022/10/1 */public class CoinsWayNoLimit {    public static int coinsWay(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        return process(arr,0, aim);    }    public static int process(int[] arr, int index, int rest){        //当到达数组最后一个元素时, 如果剩余的金额为 0 ,则有一种方法, 没有则为 返回 0        if (arr.length == index){            return rest == 0 ? 1 : 0;        }        int ways = 0;        //次数循环使用当前使用改面值的张数        for (int zhang = 0; zhang * arr[index] <= rest; zhang++){            ways += process(arr, index + 1, rest - (zhang * arr[index]));        }        return ways;    }    public static int dp1(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        int N = arr.length;        int[][] dp = new int[N + 1][aim + 1];        //根据递归尝试可得到 当数组下标到界时, 剩余金币为 0 才可以返回 1        dp[N][0] = 1;        for (int i = N - 1; i >= 0; i--) {            for (int rest = 0; rest < aim + 1; rest++) {                //次数循环使用当前使用改面值的张数                int way = 0;                for (int zhang = 0; zhang * arr[i] <= rest; zhang++){                    way += dp[i + 1][rest - (zhang * arr[i])];                }                dp[i][rest] = way;            }        }        return dp[0][aim];    }    /**     * 根据严格表依赖进行空间优化     */    public static int dp2(int[] arr, int aim){        if (arr == null || arr.length == 0 || aim < 0){            return 0;        }        int N = arr.length;        int[][] dp = new int[N + 1][aim + 1];        //根据递归尝试可得到 当数组下标到界时, 剩余金币为 0 才可以返回 1        dp[N][0] = 1;        for (int i = N - 1; i >= 0; i--) {            for (int rest = 0; rest < aim + 1; rest++) {                //严格位置依赖                dp[i][rest] = (rest - arr[i]) < 0 ?  dp[i + 1][rest]  : dp[i + 1][rest] + dp[i][rest - arr[i]];            }        }        return dp[0][aim];    }    public static int[] generateRandomArray(int maxLen, int maxValue){        int len = (int)(Math.random() * maxLen) + 1;        boolean[] repeat = new boolean[maxValue + 1];        int[] arr = new int[len];        for (int i = 0; i < len; i++) {            do {                arr[i] = (int)(Math.random() * maxValue) + 1;            }while (repeat[arr[i]]);            repeat[arr[i]] = true;        }        return arr;    }    public static void printArray(int[] arr){        System.out.println(Arrays.toString(arr));    }    public static void main(String[] args) {        int maxLen = 10;        int maxValue = 100;        int testTimes = 1000;        System.out.println("测试开始");        for (int i = 0; i < testTimes; i++) {            int[] ints = generateRandomArray(maxLen, maxValue);            int aim = (int)(Math.random() * maxValue) + 1;            int coinsWay = coinsWay(ints, aim);            int dp1 = dp1(ints, aim);            int dp2 = dp2(ints, aim);            if (coinsWay != dp1 || coinsWay != dp2){                System.out.println("coinsWay = " + coinsWay + "  :  dp1 = " + dp1 +  "  :  dp2 " + dp2 + " :  aim = "  + aim);                printArray(ints);                System.out.println("oops");                return;            }        }        System.out.println("测试结束");    }}