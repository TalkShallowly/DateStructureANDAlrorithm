package talk.dynamic;import java.util.Arrays;import java.util.Comparator;import java.util.PriorityQueue;/** * 咖啡机问题: *      给定一个数组 arr[] , 其中 arr[i] 代表第 i 号咖啡机泡一杯咖啡的时间,每个咖啡机只能串行的制造咖啡 *      给定一个正数 N, 表示有 N 个人等着咖啡机泡咖啡, 每台咖啡机只能轮流泡咖啡, 只有一台洗咖啡的机器, 一次只能洗一个杯子, 时间消耗为 a, *          洗完才能洗下一杯, 每个咖啡杯也可以自己挥发干净, 时间消耗为 b, 咖啡杯可以并行挥发, *          假设所有人等到咖啡之后立即喝干净, 返回开始等到所有咖啡杯变干净的最短时间; *              三个参数: int[] arr, int N, int a, int b * * * *          解: 此问题可分为两个问题, *              第一: 找出泡咖啡的最优排序  (小根堆结构实现) *              第二: 利用最优排序选择 洗或者挥发  (暴力递归 ---> 动态规划) * * * * @author guojunshan * @date 2022/10/8 */public class Coffee {    static class Info{        public Info(int curTime, int bubbleTime){            this.curTime = curTime;            this.bubbleTime = bubbleTime;        }        //当前来到时间        private final int curTime;        //咖啡机泡咖啡时间        private final int bubbleTime;    }    static class TimeComparable implements Comparator<Info> {        @Override        public int compare(Info o1, Info o2) {            return (o1.bubbleTime + o1.curTime) - (o2.bubbleTime + o2.curTime);        }    }//    public static int coffee(int[] arr, int N, int a, int b){//        if (arr == null || arr.length == 0 || N < 1 || a < 0 || b < 0){//            return 0;//        }//        int[] times = new int[arr.length];//        int[] drink = new int[N];//        return forceMake(arr, times, 0, drink, n, a, b);//        PriorityQueue<Info> pq = new PriorityQueue<>(new TimeComparable());//        for (int i : arr) {//            pq.add(new Info(0,i));//        }////    }    public static int right(int[] arr, int n, int a, int b) {        int[] times = new int[arr.length];        int[] drink = new int[n];        return forceMake(arr, times, 0, drink, n, a, b);    }    // 每个人暴力尝试用每一个咖啡机给自己做咖啡    public static int forceMake(int[] arr, int[] times, int kth, int[] drink, int n, int a, int b) {        if (kth == n) {            int[] drinkSorted = Arrays.copyOf(drink, kth);            Arrays.sort(drinkSorted);            return forceWash(drinkSorted, a, b, 0, 0, 0);        }        int time = Integer.MAX_VALUE;        for (int i = 0; i < arr.length; i++) {            int work = arr[i];            int pre = times[i];            drink[kth] = pre + work;            times[i] = pre + work;            time = Math.min(time, forceMake(arr, times, kth + 1, drink, n, a, b));            drink[kth] = 0;            times[i] = pre;        }        return time;    }    public static int forceWash(int[] drinks, int a, int b, int index, int washLine, int time) {        if (index == drinks.length) {            return time;        }        // 选择一：当前index号咖啡杯，选择用洗咖啡机刷干净        int wash = Math.max(drinks[index], washLine) + a;        int ans1 = forceWash(drinks, a, b, index + 1, wash, Math.max(wash, time));        // 选择二：当前index号咖啡杯，选择自然挥发        int dry = drinks[index] + b;        int ans2 = forceWash(drinks, a, b, index + 1, washLine, Math.max(dry, time));        return Math.min(ans1, ans2);    }}