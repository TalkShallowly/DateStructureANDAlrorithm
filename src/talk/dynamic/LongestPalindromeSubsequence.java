package talk.dynamic;import java.util.Arrays;/** * 动态规划: 最长回文子序列 *      问题: 给定一个字符串,返回这个字符串的最长回文子序列长度 *          eg: " a123cb4321 " , 其中最长回文子序列为: 123c321 / 123b321 /1234321 最长长度为 7 * *     注: 子序列不连续 *         子串可以连续 * * *     解法一:  (只考虑结尾的可能性) *          样本对应模型: *              思路: 生成 str 的逆串_str,让后求_str 和 str 的最长公共子序列 * *     解法二:  (开头和结尾的可能性都需要考虑) *          范围长度模型: *              定义一个方法 f(str, L, R) 求在 范围(L, R)上的最长回文序列 * * *     测试链接：https://leetcode.com/problems/longest-palindromic-subsequence/ * * @author guojunshan * @date 2022/9/19 */public class LongestPalindromeSubsequence {    /**     *  递归样例 (样本对应)     */    public int palindrome1(String str) {        if (str == null || str.length() == 0){            return 0;        }        String reverse = reverse(str);        System.out.println(reverse);        LongestCommonSubsequence longestCommonSubsequence = new LongestCommonSubsequence();        return longestCommonSubsequence.longestCommonSubsequence(str, reverse);    }    private String reverse(String str){        char[] chars = str.toCharArray();        char[] copy = new char[chars.length];        int a = 0;        for (int i = chars.length - 1; i >= 0; i--) {            copy[a++] = chars[i];        }        return Arrays.toString(copy);    }    /**     *  递归样例 (范围模型)     */    public int palindrome2(String str) {        if (str == null || str.length() == 0){            return 0;        }        char[] chars = str.toCharArray();        return process(chars,0,str.length() - 1);    }    public int process(char[] chars, int L, int R){        //剩余一个数的可能        if (L == R){            return 1;        }        //剩余两个数的可能        if (L == R - 1){            return chars[L] == chars[R] ? 2 : 1;        }        /*            可能性情况分析              1: 子序列以 L 开头, 以 R 结尾              2: 子序列以 L 开头, 不以 R 结尾              3: 子序列不以 L 开头, 不以 R 结尾              4: 子序列不以 L 开头, 以 R 结尾         */        int strategy_01 = chars[L] != chars[R] ? 0 : (2 + process(chars, L + 1, R - 1));        int strategy_02 = process(chars, L, R - 1);        int strategy_03 = process(chars, L + 1, R - 1);        int strategy_04 = process(chars, L + 1, R);        return Math.max(Math.max(strategy_01,strategy_02),Math.max(strategy_03,strategy_04));    }    /**     * 动态规划 -- 范围尝试模型     */    public int palindromeDynamic(String str) {        if (str == null || str.length() == 0){            return 0;        }        char[] chars = str.toCharArray();        int length = str.length();        int[][] db = new int[length][length];        //对角线数据为 1        db[length - 1][length - 1] = 1;        for (int i = 0; i < length - 1; i++) {            db[i][i] = 1;            db[i][i + 1] = chars[i] == chars[i + 1] ? 2 : 1;        }        //版本一: 都依赖位置都进行最大值的判断        for (int i = length - 3; i >= 0; i--) {            for (int j= i + 2; j < length; j++) {                //版本一: 都依赖位置都进行最大值的判断//                db[i][j] = Math.max(Math.max(db[i][j - 1],db[i + 1][j - 1]),db[i + 1][j]);                //版本二: 对于每个位置都需要依赖左下,右下,左对角线的位置,其中个可根据前面填充的数据来看, 左对角线的位置不会出现最大值                db[i][j] = Math.max(db[i][j - 1],db[i + 1][j]);                if (chars[i] == chars[j]){                    db[i][j] = Math.max(db[i][j], 2 + db[i + 1][j - 1]);                }            }        }        return db[0][length - 1];    }    public static void main(String[] args) {        LongestPalindromeSubsequence palindrome = new LongestPalindromeSubsequence();        System.out.println(palindrome.palindrome1("a123cb4321"));    }}