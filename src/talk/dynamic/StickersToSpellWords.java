package talk.dynamic;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * 问题: *      给定一个字符串 str ,给定一个字符类型的数据 arr, 其中 arr 中出现的字符都是小写英文的, 代表一张贴纸, *          其中每一张贴纸都有无限张, 可以将单个字符剪开使用, 目的是拼接出 str, 求至少需要多少张贴纸可以完成这个任务, * *          eg: str = "babac"   arr{"ba","c","abcd"} * *          至少需要两张贴纸, 因为使用 abcd 这两张贴纸, 将每一个字符单独剪开, *          会有 2 个 a, 2 个 b, 2 个 c,是可以拼出 str 的, 返回结果 2 * * *  本题测试链接：https://leetcode.com/problems/stickers-to-spell-word * * * * @author guojunshan * @date 2022/10/8 */public class StickersToSpellWords  {    /**     * 方式一: 暴力递归     * @param stickers 贴纸数组     * @param target 目标字符串     * @return 所需最少贴纸     */    public static int minStickers(String[] stickers, String target) {        if (target == null || target.equals("") || stickers == null || stickers.length == 0){            return 0;        }        int process = process(stickers, target);        return process == Integer.MAX_VALUE ? -1 : process;    }    private static int process(String[] stickers, String rest){        //当剩余字符的长度为 0 时, 则已经被清空, 返回 0        if (rest.length() == 0){            return 0;        }        int min = Integer.MAX_VALUE;        for (String sticker : stickers) {            //字符处理, 将当前贴纸中包含的有目标字符所需字符串在目标字符中剔除            String target = strHandle(rest, sticker);            //当前字符是否处理了目标字符            if (rest.length() != target.length()) {                min = Math.min(min, process(stickers, target));            }        }        //如果在上面遍历过程中, 根据递归返回值,如果返回 0,则 rest 被处理完成, 则需添加一种方式        return min + (min == Integer.MAX_VALUE ? 0 : 1);    }    /**     * 字符处理函数 --> 给定两个字符串, 将一个字符串中的所有字符在另一个字符串中消除, 返回剩余字符     * @param target 目标字符     * @param str 处理字符     * @return 剩余字符     */    private static String strHandle(String target, String str){        char[] tar = target.toCharArray();        char[] sou = str.toCharArray();        //字符 词频统计表        int[] record = new int[26];        for (char c : tar) {            record[c - 'a']++;        }        for (char c : sou) {          record[c - 'a']--;        }        StringBuilder sb = new StringBuilder();        //还原词频统计        for (int i = 0; i < record.length; i++) {            for (int j = 0; j < record[i]; j++) {                sb.append((char) (i + 'a'));            }        }        return sb.toString();    }    private static String strHandle2(String target, int[] count){        char[] chars = target.toCharArray();        int[] help = new int[26];        for (char cha : chars){            if (count[cha - 'a'] == 0) {                help[cha - 'a']++;            }        }        StringBuilder sb = new StringBuilder();        for (int i = 0; i < help.length; i++) {            if (help[i] != 0){                for (int j = 0; j < help[i]; j++) {                    sb.append((char) (i + 'a'));                }            }        }        return sb.toString();    }    /**     * 方式二: 递归优化     * @param stickers 贴纸数组     * @param target 目标字符串     * @return 所需最少贴纸     */    public static int minStickers2(String[] stickers, String target) {        if (target == null || target.equals("") || stickers == null || stickers.length == 0){            return 0;        }        int N = stickers.length;        //使用词频统计替换贴纸数组        int[][] count = new int[N][26];        //生成词频统计表代替贴纸数组        for (int i = 0; i < N; i++) {            char[] chars = stickers[i].toCharArray();            for (char cha : chars){                count[i][cha - 'a']++;            }        }        int process = process2(count, target);        return process == Integer.MAX_VALUE ? -1 : process;    }    /**     *     * @param stickers 词频统计表     * @param rest 剩余目标字符     * @return 所需最少贴纸     */    private static int process2(int[][] stickers, String rest){        //当剩余字符的长度为 0 时, 则已经被清空, 返回 0        if (rest.length() == 0){            return 0;        }        //将目标字符转为词频        char[] chars = rest.toCharArray();        int[] target = new int[26];        for (char aChar : chars) {            target[aChar - 'a']++;        }        int min = Integer.MAX_VALUE;        //遍历词频表中每一张贴纸对应的词频        for (int[] sticker : stickers) {            //优化点: 递归剪枝 ---> 判断当前词频中是否有目标字符, 只需判断一个,            // 即便不包含第一个, 在后序处理中将目标词频剔除一部分, 就可得到计算            if (sticker[chars[0] - 'a'] > 0) {                StringBuilder builder = new StringBuilder();                //从 target 中去除当前包含字符                for (int j = 0; j < 26; j++) {                    if (target[j] > 0) {                        int num = target[j] - sticker[j];                        for (int i = 0; i < num; i++) {                            builder.append((char)(j + 'a'));                        }                    }                }                min = Math.min(min, process2(stickers, builder.toString()));            }        }        //如果在上面遍历过程中, rest 有被处理完成, 则需要增减一种方式        return min + (min == Integer.MAX_VALUE ? 0 : 1);    }    /**     * 方式二: 递归优化 + 记忆化搜索     * @param stickers 贴纸数组     * @param target 目标字符串     * @return 所需最少贴纸     */    public static int minStickers3(String[] stickers, String target) {        if (target == null || target.equals("") || stickers == null || stickers.length == 0){            return 0;        }        int N = stickers.length;        //使用词频统计替换贴纸数组        int[][] count = new int[N][26];        //生成词频统计表代替贴纸数组        for (int i = 0; i < N; i++) {            char[] chars = stickers[i].toCharArray();            for (char cha : chars){                count[i][cha - 'a']++;            }        }        Map<String, Integer> dp = new HashMap<>();        int process = process3(count, target, dp);        return process == Integer.MAX_VALUE ? -1 : process;    }    /**     *     * @param stickers 词频统计表     * @param rest 剩余目标字符     * @return 所需最少贴纸     */    private static int process3(int[][] stickers, String rest, Map<String,Integer> dp){        if (dp.containsKey(rest)){            return dp.get(rest);        }        //当剩余字符的长度为 0 时, 则已经被清空, 返回 0        if (rest.length() == 0){            return 0;        }        //将目标字符转为词频        char[] chars = rest.toCharArray();        int[] target = new int[26];        for (char aChar : chars) {            target[aChar - 'a']++;        }        int min = Integer.MAX_VALUE;        //遍历词频表中每一张贴纸对应的词频        for (int[] sticker : stickers) {            //优化点: 递归剪枝 ---> 判断当前词频中是否有目标字符, 只需判断一个,            // 即便不包含第一个, 在后序处理中将目标词频剔除一部分, 就可得到计算            if (sticker[chars[0] - 'a'] > 0) {                StringBuilder builder = new StringBuilder();                //从 target 中去除当前包含字符                for (int j = 0; j < 26; j++) {                    if (target[j] > 0) {                        int num = target[j] - sticker[j];                        for (int i = 0; i < num; i++) {                            builder.append((char)(j + 'a'));                        }                    }                }                min = Math.min(min, process3(stickers, builder.toString(), dp));            }        }        int ans = min + (min == Integer.MAX_VALUE ? 0 : 1);        dp.put(rest, ans);        //如果在上面遍历过程中, rest 有被处理完成, 则需要增减一种方式        return ans;    }    public static void main(String[] args) {        String[] stickers = {"these","guess","about","garden","him"};        String target = "atomher";        System.out.println(minStickers(stickers, target));        System.out.println(minStickers2(stickers, target));        System.out.println(minStickers3(stickers, target));    }}