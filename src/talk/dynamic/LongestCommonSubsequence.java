package talk.dynamic;/** * 暴力递归到动态规划: *  最长公共子序列问题: (样本对应模型) *      给定两个字符串,求返回字符串中最长的公共子序列 ? *      eg: [123vdvad456] [123ddddd56]  --- > [123dd] * * *  测试链接：https://leetcode.com/problems/longest-common-subsequence/ * @author guojunshan * @date 2022/8/9 */public class LongestCommonSubsequence {    public int longestCommonSubsequence(String str1, String str2){        if (str1 == null || str1.length() == 0 || str2 == null || str2.length() == 0){            return 0;        }        return process(str1.toCharArray(), str2.toCharArray(), str1.length() - 1 , str2.length() - 1);    }    /**     * 递归逻辑     * @param str1 字符组 1     * @param str2 字符组 1     * @param i 字符组 1 对应索引     * @param j 字符组 2 对应索引     * @return 最长的公共子序列     */    private int process(char[] str1, char[] str2, int i, int j){        // 情况一: 两个数据都剩下一个字符, 如是相同则累计 1        if (i == 0 && j == 0){            return str1[i] == str2[j] ? 1 : 0;        }        /*           情况二: 如果其中一个数组剩余一个字符,首先需要判断剩余的字符和另一个字符是否相同,                如果是: 则直接返回 1                不是:   则需要对于另一个数组进行 再次处理         */        else if (i == 0){            if (str1[i] == str2[j]){                return 1;            }else {                return process(str1, str2, i, j - 1);            }        }        else if (j == 0){            if (str1[i] == str2[j]){                return 1;            }else {                return process(str1, str2, i - 1, j);            }        }        /*            情况三:  分为 4 类                a: 一定不以 i 为公共子序列的结尾, 一定不以 j 为结尾 范围: str[0....i-1]   str[0....j-1]                b: 一定不以 i 为公共子序列的结尾, 可能以 j 为结尾 范围: str[0....i-1]   str[0....j]                c: 可能 i 为公共子序列的结尾, 一定不以 j 为结尾 范围: str[0....i]   str[0....j-1]                d: 可能 i 为公共子序列的结尾, 可能以 j 为结尾                        成立条件 str[i] == str[j]          范围: str[0....i]   str[0....j]             总结: 有以上 4 中可能性分析可知:                在范围上 : b 和 c 的并集包含 a ,所以在大小值判定 a 只能 < max(b,c), 所以在此 a 存在是否,无关系         */        else {            int c = process(str1, str2, i, j - 1);            int b = process(str1, str2, i - 1, j);            int res = Math.max(c, b);            if (str1[i] == str2[j]){                res = Math.max(res,(1 + process(str1, str2, i - 1, j - 1)));            }            return res;        }    }    /**     * 动态规划     */    public int longestCommonSubsequence_dynamic(String str1, String str2){        if (str1 == null || str1.length() == 0 || str2 == null || str2.length() == 0){            return 0;        }        char[] chars1 = str1.toCharArray();        char[] chars2 = str2.toCharArray();        int len1 = str1.length();        int len2 = str2.length();        int[][] dp = new int[len1][len2];        //  i == 0 && j == 0 的情况        dp[0][0] = chars1[0] == chars2[0] ? 1 : 0;        //  i == 0 的情况        for (int i = 1; i < len2; i++) {            dp[0][i] = chars1[0] == chars2[i] ? 1 : dp[0][i - 1];        }        //  j == 0 的情况        for (int i = 1; i < len1; i++) {            dp[i][0] = chars1[i] == chars2[0] ? 1 : dp[i - 1][0];        }        //  i != 0 && j != 0 的情况        for (int i = 1; i < len1; i++) {            for (int j = 1; j < len2; j++) {                int res = Math.max(dp[i][j - 1], dp[i - 1][j]);                dp[i][j] =  chars1[i] == chars2[j] ? Math.max(res, (1 + dp[i - 1][j - 1])) : res;            }        }        return dp[len1 - 1][len2 - 1];    }}