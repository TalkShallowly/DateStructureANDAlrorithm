package talk.dynamic;/** * 问题: * 给定 5 个参数,  N, M, row, col, K * 表示在 N * M 的区域上, 有一个醉汉 Bod 初始在 (row, col)的位置 * Bob 一共需要迈出 K 步, 且每一步都会等概率向上/下/左/右 四个方向走一个单位, 任何时候 Bod 只要离开 N * M 的区域, 就直接死亡 * 求走完 K 步之后, Bob 还在 N * M 区域的概率 * * @author guojunshan * @date 2022/10/2 */public class BodDie {    public static double bodDie(int N, int M, int row, int col, int K) {        //假设棋盘无线大, 则总步数为 4 ^ k        return (double) process(N, M, row, col, K) / Math.pow(4, K);    }    /**     *     * @param N 行边界     * @param M 列边界     * @param curRow 当前行的位置     * @param curCol 当前列的位置     * @param rest 剩余步数     * @return 不去棋盘的总步数     */    private static long process(int N, int M, int curRow, int curCol, int rest) {        if (curRow < 0 || curRow == N || curCol < 0 || curCol == M) {            return 0;        }        if (rest == 0) {            return 1;        }        //向上        long way = process(N, M, curRow + 1, curCol, rest - 1);        //向下        way += process(N, M, curRow - 1, curCol, rest - 1);        //向右        way += process(N, M, curRow, curCol + 1, rest - 1);        //向左        way += process(N, M, curRow, curCol - 1, rest - 1);        return way;    }    public static double dp(int N, int M, int row, int col, int K) {        if (row < 0 || row >= N || col < 0 || col >= M || K < 0) {            return 0;        }        int[][][] dp = new int[N][M][K + 1];        for (int i = 0; i < N; i++) {            for (int j = 0; j < N; j++) {                dp[i][j][0] = 1;            }        }        for (int z = 1; z <= K; z++) {            for (int i = 0; i < N; i++) {                for (int j = 0; j < M; j++) {                    dp[i][j][z] = pick(dp, N, M, i + 1, j, z - 1)                            + pick(dp, N, M, i - 1, j, z - 1)                            + pick(dp, N, M, i, j + 1, z - 1)                            + pick(dp, N, M, i, j - 1, z - 1);                }            }        }        return (double) dp[row][col][K] / Math.pow(4, K);    }    private static int pick(int[][][] dp, int N, int M, int row, int col, int K) {        if (row < 0 || row >= N || col < 0 || col >= M) {            return 0;        }        return dp[row][col][K];    }    public static void main(String[] args) {        int N = 10;        int M = 10;        int row = 2;        int col = 2;        int K = 9;        double aDouble = bodDie(N, M, row, col, K);        double dp = dp(N, M, row, col, K);        System.out.println(aDouble + " : " + dp);    }}