package talk.dynamic;/** * <pre> * 暴力递归到动态归还: * *      问题一： 假设有排成一行的 N 个位置记为 1～N，开始时机器人在 M 位置, M 范围为 1~N 之间, *              如果 M = 1,则下一步只能向右移动, 如果 M = N, 则下一步只能向左移动, *              请返回有多少种移动方式? *  </pre> * * @author guojunshan * @date 2022/8/8 */public class RobotWalk {    /**     * 递归解     * @param N 位置长度     * @param start 开始位置     * @param aim 目标位置     * @param K 要走多少步     * @return 多少种移动方式     */    public static int ways_recursion(int N, int start, int aim, int K){        if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1){            return -1;        }        return process(start,aim,K,N);    }    /**     *     * @param cur 当前来到的位置     * @param arm 目标位置     * @param rest 剩余步数     * @param N 总位置长度     * @return 移动访方式     */    private static int process(int cur,int arm, int rest,int N){        //当剩余步数为 0 ,并且当前位置在目标位置上则返回 1        if (rest == 0){            return cur == arm ? 1 : 0;        }        //如果当前位置来到 1,则下一步需要向右走        if (cur == 1){            return process(cur + 1,arm,rest - 1,N);        }        //如果当前位置来到 N, 则下一步需要向左走        if (cur == N){            return process(cur - 1,arm,rest - 1,N);        }        //当前位置不在两边界上,则可以从左边和从右边都可以走        return process(cur + 1,arm,rest - 1,N) + process(cur - 1,arm,rest - 1,N);    }    /**     * 递归 -- 傻缓存法     * @param N 位置长度     * @param start 开始位置     * @param aim 目标位置     * @param K 要走多少步     * @return 多少种移动方式     */    public static int ways_cache(int N, int start, int aim, int K){        if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1){            return -1;        }        //初始化缓存        int[][] dp = new int[N + 1][K + 1];        for (int i = 0; i <= N; i++) {            for (int j = 0; j <= K; j++) {                dp[i][j] = -1;            }        }        return process_02(start,aim,K,N,dp);    }    /**     *     * @param cur 当前来到的位置     * @param arm 目标位置     * @param rest 剩余步数     * @param N 总位置长度     * @param dp 缓存表     * @return 移动访方式     */    private static int process_02(int cur,int arm, int rest, int N, int[][] dp){        if (dp[cur][rest] != -1){            return dp[cur][rest];        }        int res = 0;        if (rest == 0 && cur == arm){            res =  1;        }else if (cur == 1){            res = process(cur + 1,arm,rest - 1,N);        } else if (cur == N){            res = process(cur - 1,arm,rest - 1,N);        }else {            res = process(cur + 1,arm,rest - 1,N) + process(cur - 1,arm,rest - 1,N);        }        //将结果添加缓存        dp[cur][rest] = res;        return res;    }    /**     * 动态规划 -- 二维缓存表     * @param N 位置长度     * @param start 开始位置     * @param aim 目标位置     * @param K 要走多少步     * @return 多少种移动方式     */    public static int ways_dynamic(int N, int start, int aim, int K){        if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1){            return -1;        }        //依据当前位置和剩余步数创立二维表        int[][] dp = new int[N + 1][K + 1];        //根据递归条件分析得 : 目标位置的 0 位置返回 1        dp[aim][0] = 1;        for (int i = 1; i <= K; i++) {            //边界条件: 第一行的数据依赖第二行的前面一列数据            dp[1][i] = dp[2][i - 1];            //边界条件: 第 N 行的数据依赖第 N - 1 行的前面一列数据            dp[N][i] = dp[N - 1][i - 1];            for (int j = 2; j < N; j++){                dp[j][i] = dp[j - 1][i - 1] + dp[j + 1][i - 1];            }        }        //打印二维数据表//        for (int[] ints : dp) {//            for (int anInt : ints) {//                System.out.print(anInt + " \t");//            }//            System.out.println();//        }        return dp[start][K];    }    public static void main(String[] args) {        System.out.println(ways_recursion(5,2,4,4));        System.out.println(ways_cache(5,2,4,4));        System.out.println(ways_dynamic(5,2,4,4));    }}