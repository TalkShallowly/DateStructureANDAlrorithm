package talk.dynamic;/** * 问题: *      给定一个正数数组 arr[] *          请将 arr[]中的所有的数分割为两个集合, 尽量让两个集合的累加和接近返回, *          最接近的情况下, 返回较小集合的累加和 * * *          动态规划: 从左向右的尝试模型 * * * @author guojunshan * @date 2022/10/8 */public class SplitSumClosed {    public static int spiltArrSum(int[] arr) {        if (arr == null || arr.length == 0) {            return 0;        }        //首先,需要计算源数组的累加和 (当分割为两个集合的累计和最接近的时候, 较小集合的累加和一定 <= sum / 2)        int sum = 0;        for (int j : arr) {            sum += j;        }        return process(arr, 0, sum / 2);    }    /**     * 尝试策略     * @param arr 源数组     * @param index 当前数据来到的索引     * @param limit 数据的 累加和限制     * @return 累加和接近情况下的, 较小集合的累加和     */    private static int process(int[] arr, int index, int limit) {        //当没有数的情况下        if (index == arr.length) {            return 0;        }        //不需要当前索引的数据        int p1 = process(arr, index + 1, limit);        int p2 = 0;        //需要当前数据的数据, 但前提是当前数据必须 <= 限制和        if (arr[index] <= limit) {            p2 = process(arr, index + 1, limit - arr[index]) + arr[index];        }        return Math.max(p1, p2);    }    public static int dp(int[] arr){        if (arr == null || arr.length == 0) {            return 0;        }        int sum = 0;        for (int j : arr) {            sum += j;        }        int N = arr.length;        int rest = sum / 2;        int[][] dp = new int[N + 1][rest + 1];        //填充第 N 行的数据        for (int i = 0; i <= rest; i++) {            dp[N][i] = 0;        }        for (int index = N - 1; index >= 0; index--) {            for (int limit = rest; limit >= 0; limit--) {                int p1 = dp[index + 1][limit];                int p2 = 0;                if (arr[index] <= limit) {                    p2 = dp[index + 1][limit - arr[index]] + arr[index];                }                dp[index][limit] = Math.max(p1, p2);            }        }        return dp[0][rest];    }    private static int[] generateRandomArrays(int maxLen, int maxValue) {        int len = (int) (Math.random() * maxLen) + 1;        int[] ints = new int[len];        for (int i = 0; i < len; i++) {            ints[i] = (int) (Math.random() * maxValue) + 1;        }        return ints;    }    public static void main(String[] args) {        int maxLen = 20;        int maxValue = 100;        int testCount = 10000;        System.out.println("测试开始!");        for (int i = 0; i < testCount; i++) {            int[] ints = generateRandomArrays(maxLen, maxValue);            int i1 = spiltArrSum(ints);            int dp = dp(ints);            if (dp != i1){                System.out.println(" i1 : " + i1 + " --- dp : " + dp);                return;            }        }        System.out.println("测试结束!");    }}