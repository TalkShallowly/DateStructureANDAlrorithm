package talk.manachar;import java.util.Arrays;import java.util.LinkedList;import java.util.List;/** * Manachar 算法: *      Manachar算法主要是处理字符串中关于回文串的问题，它可以在 O（n） 的时间处理出以字符串中每一个字符为中心的回文串半径， *      由于将原字符串处理成两倍长度的新串，在每两个字符之间加入一个特定的特殊字符， *      因此原本长度为偶数的回文串就成了以中间特殊字符为中心的奇数长度的回文串了。 *        Manacher算法提供了一种巧妙的办法，将长度为奇数的回文串和长度为偶数的回文串一起考虑， *            具体做法是，在原字符串的每个相邻两个字符中间插入一个分隔符， *            同时在首尾也要添加一个分隔符，分隔符的要求是不在原串中出现， * * *            注: 一般情况下可以用#号。 * * *       技巧点: *          回文半径 *          回文直径 *          回文半径数组 *          最右回文边界 ( R: 记录右边界  C: 记录扩散位置 ) *              1: i 未被 R 扩注,则无法进行优化,暴力扩充 *              2: i 被 R 扩住, 则存在 [...i'...C....i...] *                  其中 i' 的扩散信息在回文半径中 * *               第一种: 若 i' 在 L~R 范围内部, 则 i = i' *               第二种: i' 超过 L~R 范围边界, 则 i~R 距离则为回文半径 *               第三种: i 的左区域与 i' 压线, 则需对比回文半径与下一个字符 * * */public class Manachar {    public static int manachar(String str) {        if (str == null || str.length() == 0){            return 0;        }        //预处理字符串        char[] chars = manacharStr(str);        //回文半径大小        int[] pArr = new int[chars.length];        //C代表: 当前在那个位置进行向右扩充        int C = -1;        // R：表示从 -1 开始, 每个位置的最右扩成功的位置        int R = -1;        int maxPalindromeLen = Integer.MIN_VALUE;        for (int i = 0; i < chars.length; i++) {            /*              当 R <= i, 则 i 的最右半径即为自己              当 R > i, 则存在以下两种情况:                             L              C              R                    eg:  a d 1 2 3 2 1 d a  F  a d 1 2 3 2 1 ? ?                                 i'                    i                  第一种: i 对C 的对称位置 i' 的回文半径超过 L~R 范围, (d != ?) 则当前 i 可扩回文半径为 R - i                  第二种: i 对C 的对称位置 i' 的回文半径没有超过 L~R 的范围 (d == ?) 则当前 i 只可以在 L~R 范围内可扩回文半径为 2 * C - i             */            pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1;            //当前位置的最少回文半径的可扩位置越界            while (i + pArr[i] < chars.length && i - pArr[i] > -1) {                //比较当前位置的左右可扩位置, 相等则可继续向左右扩, 不一样则最少可以范围即为当前位置的回文半径                if (chars[i + pArr[i]] == chars[i - pArr[i]])                    pArr[i]++;                else {                    break;                }            }            // 如果 i 位置扩展完成之后的范围超过 R, 则需要更新 R 位置和 C 位置            if (i + pArr[i] > R) {                R = i + pArr[i];                C = i;            }            //更新最大回文长度            maxPalindromeLen = Math.max(maxPalindromeLen, pArr[i]);        }        //因为数组属于特殊处理过的字符, 处理过的字符的 [回文半径 - 1] 即为目标数组的最长回文直径        return maxPalindromeLen - 1;    }    private static char[] manacharStr(String str){        char[] chars = str.toCharArray();        char[] processChars = new char[2 * chars.length + 1];        int j = 0;        for (int i = 0; i < processChars.length; i++) {            processChars[i] = (i & 1) == 0 ? '#' : chars[j++];        }        return processChars;    }    /**     * 暴力枚举测试(以每个位置为标准向左右两边进行比较扩充)     * @param str 目标字符串     * @return 最长回文半径     */    public static int test(String str){        if (str == null || str.length() == 0){            return 0;        }        //测试需要特殊处理: 不处理不好统计偶数情况下的回文        char[] chars = manacharStr(str);        int maxPalindromeLen = Integer.MIN_VALUE;        for (int i = 0; i < chars.length; i++) {            maxPalindromeLen = Math.max(maxPalindromeLen, process(chars, i));        }        return maxPalindromeLen;    }    /**     * 传递的为处理过的字符, 记录当前位置的回文半径,即为原数据的回文长度 枚举每一项     * @param chars 目标数组     * @param index 当前到达索引     * @return 统计的长度     */    private static int process(char[] chars, int index){        if (index == 0){            return 1;        }        int maxLen = 1;        int min = Math.min(chars.length - index - 1, index);        for (int i = 1; i <= min; i++) {            if (chars[index - i] == chars[index + i]){                maxLen++;            }else {                break;            }        }        return maxLen - 1;    }    public static String generateRandomStr(int possibilities, int maxLen){        int len = (int) (Math.random() * maxLen) + 1;        char[] chars = new char[len];        for (int i = 0; i < len; i++) {            chars[i] = (char) ((int) (Math.random() * possibilities) + 'a');        }        return String.valueOf(chars);    }    public static void main(String[] args) {        int maxLength = 1000;        int possibilities = 10;        int testTime = 10000;        System.out.println("test.......Start.....");        for (int i = 0; i < testTime; i++) {            String str = generateRandomStr(possibilities, maxLength);            int manachar = manachar(str);            int test = test(str);            if (manachar != test){                System.out.println(str);                System.out.println("manachar:  " + manachar);                System.out.println("test:  " + test);                return;            }        }        System.out.println("test......End");    }}