package talk.graph;import java.util.*;/** * 迪杰斯特拉算法: *      该算法解决了图上带权的单源最短路径问题 *      举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径 * *      算法核心点: 对某一节点生成与其他节点的最短路径表 (最大路径表示无法到达) * *      缺点: *          1: 算法时间考察的每个节点每次都需要遍历一次全节点路径 --> 时间复杂度较大 *          2: 不能有效处理带有负权边的图 *      优化: 使用 [加强堆] 结构 */public class Dijkstra {    public static Map<Node,Integer> dijkstraMST(Node from){        //第一: 随便逮出任意一个节点,将该节点到其他节点的路径维护在索引表中        Map<Node,Integer> distanceMap = new HashMap<>();        distanceMap.put(from,0);        // 打过对号的点        HashSet<Node> selectedNodes = new HashSet<>();        Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);        while (minNode != null){            //  原始点  ->  minNode(跳转点)   最小距离distance            int distance = distanceMap.get(minNode);            for (Edge edge : minNode.edges){                if (selectedNodes.contains(edge.to)){                    distanceMap.put(edge.to,Math.min(distanceMap.get(edge.to),distance + edge.weight));                }else {                    distanceMap.put(edge.to,distance + edge.weight);                }            }            selectedNodes.add(minNode);            minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);        }        return distanceMap;    }    /**     *  从未选择的节点中获取路径最小的点     * @param distanceMap 节点路径索引表     * @param touchedNodes 已经选择了的节点     * @return 最小节点     */    private static Node getMinDistanceAndUnselectedNode(Map<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {        Node minNode = null;        int minDistance = Integer.MAX_VALUE;        for (Map.Entry<Node, Integer> entry : distanceMap.entrySet()) {            Node node = entry.getKey();            int distance = entry.getValue();            if (!touchedNodes.contains(node) && distance < minDistance) {                minNode = node;                minDistance = distance;            }        }        return minNode;    }    /**     *  节点路径对象     */    public static class NodeRecord {        public Node node;        public int distance;        public NodeRecord(Node node, int distance) {            this.node = node;            this.distance = distance;        }    }    /**     * 使用扩展堆结构     */    public static class ExtendedHead{        //节点数据        private Node[] nodes;        //反向索引表 (在删除元素的时候,只在堆结构中进行删除,在反向索引表中将索引设置为 -1 , 逻辑删除)        private final Map<Node,Integer> heapIndexMap;        //其中一个节点到其他节点的距离        private final Map<Node, Integer> distanceMap;        //堆上的点        private int size;        ExtendedHead(int _size){            nodes = new Node[_size];            heapIndexMap = new HashMap<>();            distanceMap = new HashMap<>();            size = 0;        }        public boolean isEmpty(){            return size == 0;        }        /**         * 节点是否存在         * @param node 节点信息         * @return true | false         */        public boolean isExisted(Node node){            return heapIndexMap.containsKey(node);        }        // 有一个点node，现在发现了一个从源节点出发到达node的距离为distance        // 判断要不要更新，如果需要的话，就更新        public void addOrUpdateOrIgnore(Node node,int distance){            //如果存在,并且未被删除, 则进行更新            if (inHeap(node)){                distanceMap.put(node, Math.min(distanceMap.get(node),distance));                heapInsert(heapIndexMap.get(node));            }            //如果节点没有存在过            if (!isExisted(node)){                nodes[size] = node;                distanceMap.put(node, distance);                heapIndexMap.put(node,size);                heapInsert(size++);            }        }        public NodeRecord pop(){            NodeRecord nodeRecord = new NodeRecord(nodes[0],distanceMap.get(nodes[0]));            swap(0,--size);            heapIndexMap.put(nodes[size],-1);            distanceMap.remove(nodes[size]);            nodes[size] = null;            heapify(0);            return nodeRecord;        }        /**         * 是否存在过, 并且在堆中没有删除         * @param node 节点信息         * @return true | false         */        private boolean inHeap(Node node) {            return isExisted(node) && heapIndexMap.get(node) != -1;        }        /**         * 从上向下进行调整         * @param index 调整开始索引         */        private void heapify(int index){            int leftIndex = (index << 1) + 1;            while (leftIndex < size){                int smallIndex = leftIndex + 1 < size && distanceMap.get(nodes[leftIndex]) < distanceMap.get(nodes[leftIndex + 1]) ? leftIndex + 1 : leftIndex;                smallIndex = distanceMap.get(nodes[smallIndex]) < distanceMap.get(nodes[index]) ? smallIndex : index;                if (index == smallIndex){                    break;                }                swap(index,smallIndex);                index = smallIndex;                leftIndex = (index << 1) + 1;            }        }        /**         * 从下向上调整堆结构         * @param index 开始索引         */        private void heapInsert(int index){            while (index >= 0 && distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1 >> 1)])){                swap(index,index - 1 >> 1);                index = index - 1 >> 1;            }        }        private void swap(int i ,int j){            if (i == j) return;            heapIndexMap.put(nodes[i],j);            heapIndexMap.put(nodes[j],i);            Node temp = nodes[i];            nodes[i] = nodes[j];            nodes[j] = temp;        }    }    /**     * 使用堆结构进行优化     * @param from 开始节点     * @param size 节点数量     * @return 节点对应最小路径表     */    public static Map<Node,Integer> dijkstraMST_02(Node from,int size){        ExtendedHead extendedHead = new ExtendedHead(size);        extendedHead.addOrUpdateOrIgnore(from,0);        Map<Node,Integer> result = new HashMap<>();        while (!extendedHead.isEmpty()){            NodeRecord nodeRecord = extendedHead.pop();            for (Edge cur : nodeRecord.node.edges){                extendedHead.addOrUpdateOrIgnore(cur.to,nodeRecord.distance + cur.weight);            }            result.put(nodeRecord.node,nodeRecord.distance);        }        return result;    }}