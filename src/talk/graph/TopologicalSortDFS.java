package talk.graph;import java.util.*;/** * 拓扑排序 : * *     DFS 实现: *           如果: A 的 DFS < B 的 DFS *              那么: A 在 B 触发点之前 * *  题目链接: https://www.lintcode.com/problem/127/ * */public class TopologicalSortDFS {    public static class DirectedGraphNode {        int label;        List<DirectedGraphNode> neighbors;        DirectedGraphNode(int x){            this.label = x;            neighbors = new ArrayList<>();        }    }    public static class Record{        private final DirectedGraphNode node;        private final int depth;        Record(DirectedGraphNode _node, int _depth){            this.node = _node;            this.depth = _depth;        }    }    public static class MyComparator implements Comparator<Record> {        @Override        public int compare(Record o1, Record o2) {            return o2.depth - o1.depth;        }    }    /**     * 递归方式 实现     * @param graph 图     */    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {        if (graph == null) {            return null;        }        //第一步: 递归维护 DFS 索引表        Map<DirectedGraphNode, Record> depthMap = new HashMap<>();        for (DirectedGraphNode cur : graph){            recursion(cur,depthMap);        }        //第二步: 将图节点作为 基类进行从小到大排序        List<Record> list = new ArrayList<>(depthMap.values());        list.sort(new MyComparator());        //第三步: 输出        ArrayList<DirectedGraphNode> ans = new ArrayList<>();        list.forEach(x -> ans.add(x.node));        return ans;    }    public Record recursion(DirectedGraphNode cur, Map<DirectedGraphNode, Record> order) {        if (order.containsKey(cur)) {            return order.get(cur);        }        int follow = 0;        for (DirectedGraphNode next : cur.neighbors) {            follow = Math.max(follow, recursion(next, order).depth);        }        Record ans = new Record(cur, follow + 1);        order.put(cur, ans);        return ans;    }}