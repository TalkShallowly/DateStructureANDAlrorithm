package talk.graph;import java.util.*;/** * 最小生成树算法: Kruskal 算法 ---> (无向图) * *      解释: *          1: 总是从权值最小的便开始考虑, 逐渐考察权值依次变大的边 *          2: 当前的边要么进入最小生成树集合,要么丢弃 *          3: 如果当前的边进去最小生成树集合,并且不能形成环状, 则需要这条边 -- 反之,则丢弃 *          4: 返回最小生成树 * *       使用 --> 并查集 * *       建议: 如果边的数量较多,权限较大,则使用 Prim 算法 */public class Kruskal {    //节点并查集结构    public static class UnionSet{        //节点祖先对应索引表        private final Map<Node,Node> parents;        //祖先节点的连接节点树        private final Map<Node,Integer> sizes;        UnionSet(){            parents = new HashMap<>();            sizes = new HashMap<>();        }        public void initValue(List<Node> list){            for (Node node : list){                parents.put(node,node);                sizes.put(node,0);            }        }        public Node findFather(Node node){            Node father = parents.get(node);            Stack<Node> stack = new Stack<>();            while (father != node){                stack.add(node);                node = father;                father = parents.get(node);            }            while (!stack.isEmpty()){                parents.put(stack.pop(),father);            }            return father;        }        public void union(Node o1, Node o2){            Node father_o1 = findFather(o1);            Node father_o2 = findFather(o2);            if (father_o1 != father_o2){                Node bigNode = sizes.get(father_o1) >= sizes.get(father_o2) ? father_o1 : father_o2;                Node smallNode = bigNode == father_o1 ? father_o2 : father_o1;                parents.put(smallNode,bigNode);                sizes.put(bigNode,sizes.get(father_o1) + sizes.get(father_o2));                sizes.remove(smallNode);            }        }        public boolean isSameSet(Node o1, Node o2){            return findFather(o1) == findFather(o2);        }    }    //权重比较器    public static class WeightComparator implements Comparator<Edge> {        @Override        public int compare(Edge o1, Edge o2) {            return o1.weight - o2.weight;        }    }    public static Set<Edge> kruskalMST(Graph graph){        List<Edge> edges = graph.edges;        edges.sort(new WeightComparator());        Set<Edge> result = new HashSet<>();        UnionSet unionSet = new UnionSet();        unionSet.initValue(graph.nodes);        for (Edge cur : edges){            if (!unionSet.isSameSet(cur.from,cur.to)){                result.add(cur);                unionSet.union(cur.from,cur.to);            }        }        return result;    }}