package talk.graph;import java.util.*;/** * 最小生成树算法: Prim 算法  ---> (无向图) * *      解释: *          1: 可以从任意节点出发来寻找最小生成树 *          2: 在某个节点被选中后, 解锁这个节点出发的所有新的边 *          3: 在解锁的所有边中选择最小的边,然后判断是否会形成环 *          4: 如果会, 丢弃当前边,继续考察剩余的边中的 最小边 (重复步骤 3) *          5: 如果不会,则需要当前边, 然后将该边的指向点加入被选中的点中 (重复步骤 2) *          6: 将所有点遍历完成后 ,返回最小生成树 * * *   涉及问题: *       假设graph是连通图, 其中graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路 *          求返回值是最小连通图的路径之和 */public class Prim {    public static class WeightComparator implements Comparator<Edge> {        @Override        public int compare(Edge o1, Edge o2) {            return o1.weight - o2.weight;        }    }    public static Set<Edge> primMST(Graph graph){        //使用堆结构: 对每一个解锁点的边进行排序        PriorityQueue<Edge> queue = new PriorityQueue<>(new WeightComparator());        //过滤那些点已经被遍历过        Set<Node> nodes = new HashSet<>();        //返回最小生成的边        Set<Edge> result = new HashSet<>();        for (Node cur : graph.nodes){            if (!nodes.contains(cur)){                nodes.add(cur);                queue.addAll(cur.edges);                while (!queue.isEmpty()){                    Edge curEdge = queue.poll();                    if (!nodes.contains(curEdge.to)){                        nodes.add(curEdge.to);                        result.add(curEdge);                        queue.addAll(curEdge.to.edges);                    }                }            }        }        return result;    }    // 请保证graph是连通图    // graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路    // 返回值是最小连通图的路径之和    public static int primMinPathSum(int[][] graph){        int size = graph.length;        //定义一个从 0 节点开始到最后节点路径的数据        int[] distances = new int[size];        //当前路径 是否被访问过        boolean[] visit = new boolean[size];        visit[0] = true;        for (int i = 0; i < size; i++) {            distances[i] = graph[0][i];        }        int sum = 0;        for (int i = 1; i < size; i++) {            int minPath = Integer.MAX_VALUE;            int minIndex = -1;            for (int j = 0; j < size; j++) {                if (!visit[j] && distances[j] < minPath) {                    minPath = distances[j];                    minIndex = j;                }            }            if (minIndex == -1) {                return sum;            }            visit[minIndex] = true;            sum += minPath;            for (int j = 0; j < size; j++) {                if (!visit[j] && distances[j] > graph[minIndex][j]) {                    distances[j] = graph[minIndex][j];                }            }        }        return sum;    }}