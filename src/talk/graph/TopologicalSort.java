package talk.graph;import java.util.*;/** *  拓扑排序 : 是一种在图节点的依赖关系进行顺序的输出: *      比如: *          A 和 B 同时指向 C ,那么在 C 创建时首先需要创建 A 和 B, 其中 A,B 顺序忽略 * *      排序方式: *          1: 点位排序 (BFS 排序) *              根据图节点的 入度和进行对节点排序 * *          2: DFS 排序: *              根据图节点的深度进行排序 * * * */public class TopologicalSort {    public static class MyComparator implements Comparator<Node>{        @Override        public int compare(Node o1, Node o2) {            return o1.in - o2.in;        }    }    public List<Node> topologicalSort(Graph graph){        if (graph == null){            return null;        }        // 只有剩余入度为0的点，才进入这个队列        Queue<Node> zeroInQueue = new LinkedList<>();        Map<Node,Integer> inMap = new HashMap<>();        for (Node node : graph.nodes){            inMap.put(node,node.in);            if (node.in == 0){                zeroInQueue.add(node);            }        }        List<Node> ans = new ArrayList<>();        while (!zeroInQueue.isEmpty()){            Node cur = zeroInQueue.poll();            ans.add(cur);            for (Node next : cur.nexts){                inMap.put(next, inMap.get(next) - 1);                if (inMap.get(next) == 0){                    zeroInQueue.add(next);                }            }        }        return ans;    }}