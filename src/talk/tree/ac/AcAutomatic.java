package talk.tree.ac;import java.math.BigDecimal;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;/** * AC 自动机实现 * @author guojunshan * @date 2023/3/1 */public class AcAutomatic {    private static Node curNode;    static class Node {        /**         * 下级节点         */        private Node[] nextNode = new Node[26];;        private Node fail;        private boolean endUse = false;        /**         * 是否结束节点         */        private String end;    }    public static Node trieTree(List<String> keywords){        if (keywords == null || keywords.isEmpty()){            return null;        }        Node root = new Node();        for (int i = 0; i < keywords.size(); i++) {            Node curNode = root;            char[] chars = keywords.get(i).toCharArray();            for (int j = 0; j < chars.length; j++) {                if (curNode.nextNode[chars[j] - 'a'] == null){                    curNode.nextNode[chars[j] - 'a'] = new Node();                }                curNode = curNode.nextNode[chars[j] - 'a'];            }            curNode.end = keywords.get(i);        }        return root;    }    public static void build(Node root){        if (root == null){            return;        }        Queue<Node> queue = new LinkedList();        queue.add(root);        Node curNode, failNode;        while (!queue.isEmpty()){            curNode = queue.poll();            for (int i = 0; i < 26; i++) {                if (curNode.nextNode[i] != null){                    curNode.nextNode[i].fail = root;                    failNode = curNode.fail;                    while (failNode != null){                        if (failNode.nextNode[i] != null){                            curNode.nextNode[i].fail = failNode.nextNode[i];                            break;                        }                        failNode = failNode.fail;                    }                    queue.add(curNode.nextNode[i]);                }            }        }    }    public static List<String> contailsKey(String text, Node root){        if (text == null || text.length() < 1){            return new ArrayList<>();        }        List<String> results =  new ArrayList<>();        char[] str = text.toCharArray();        Node curNode = root;        for (int i = 0; i < str.length; i++) {            int index = str[i] - 'a';            while (curNode.nextNode[index] == null && curNode != root){                curNode = curNode.fail;            }            curNode = curNode.nextNode[index] != null ? curNode.nextNode[index] : root;            Node follow = curNode;            while (follow != root){                if (follow.endUse) {                    break;                }                if (follow.end != null){                    results.add(follow.end);                    follow.endUse = true;                }                follow = follow.fail;            }        }        return results;    }    public static void main(String[] args) {        List<String> keywords = new ArrayList<>();        String text = "thebloodstainedrobeisredthroughthearmowhodarestofightinthedangyang";        keywords.add("loo");        keywords.add("arm");        keywords.add("dangf");        Node node = trieTree(keywords);        build(node);        List<String> list = contailsKey(text, node);        list.forEach(System.out::println);    }}