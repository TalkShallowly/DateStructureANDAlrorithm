总结:一: 递归套路    1: 假设以 x 节点为头, 假设可以向 x 的左树和 x 的右树要任何信息    2: 在上一步的假设下, 讨论以 x 为头节点的数, 得到答案的可能性 (最重要)    3: 列出所有可能性后, 确定到底需要向左树和右树要什么样的信息    4: 将左树信息与右树信息求全集, 就是任何一棵子树都需要返回的信息 S    5: 递归函数函数都返回 信息 S, 每一棵树都这么要求    6: 在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息 二: marris遍历 (优化空间算法)    解释: marris 利用树的最低层叶子结点的大量空指针的方法进行遍历        时间复杂度: O(N)        空间复杂度: O(1)     对于树的先序 / 中序 / 后序 遍历时, 需要额外空间复杂度为 O(h), 其中h 为树的高度    具体步骤:         1): 以 currentNode 为基准, 刚开始时在头节点, currentNode 为 head        2): 若 currentNode 无左节点, 则向右移动 (currentNode = currentNode.left)        3): 若 currentNode 有左节点, 则需要找到左子树上最右的节点 (mostRight)            a: 如果 mostRight 的右指针为 null, 则让其先指向 currentNode 节点 (对应自己的祖先节点)                然后 currentNode 向左移动 (currentNode = currentNode.right)            b: 如果 mostRight 的右指针为 currentNode, (之前修改过连接, 此时需要撤销之前的连接), 让其指向 null,                然后 currentNode 向右移动 (currentNode = currentNode.left)        4): 循环 2,3, 直到 currentNode 为 null 时结束        eg:                 A                                    B               C                D       E       F       G        分析:             cur = A, A有左节点, 则 mostRight = E, E.left 为 null 则指向 --> A, cur 左移            cur = B, B有左节点, 则 mostRight = D, D.left 为 null 则指向 --> B, cur 左移            cur = D, D无左节点, cur 右移 到 B,  (cur.left = B)            cur = B, B有左节点, 则 mostRight = D, D.left --> B, 则取消指向 设置为 null, cur 右移            cur = E, B无左节点, cur 右移 到 A,  (cur.left = A)            cur = A, A有左节点, 则 mostRight = E, E.left --> A, 则取消指向 设置为 null, cur 右移            cur = C, C有左节点, 则 mostRight = F, F.left 为 null 则指向 --> C, cur 左移            cur = F, F无左节点, cur 右移 到 C,  (cur.left = C)            cur = C, C有左节点, 则 mostRight = F, F.left --> C, 则取消指向 设置为 null, cur 右移            cur = G, G无左节点, cur 右移 为 null, 结束遍历        结论: 有左边节点的会到达两次        marris 遍历:  A --> B --> D --> B --> E --> A --> C --> F --> C --> G --> null        先序遍历:      A --> B --> D --> E --> C --> F --> G    (marris遍历: 无左边节点直接记录, 有则第一次到达时记录)        中序遍历:      D --> B --> E --> A --> F --> C --> G    (marris遍历: 无左边节点直接记录, 有则第二次到达时记录)        后序遍历:      D --> E --> B --> F --> G --> C --> A    (marris遍历: 有左节点的第二次到达时记录该节点的左树右边界 (逆序 -- 链表反转法), 最后逆序单独打印整棵树的右边界)        