package talk.tree.marris;/** * marris 遍历: *         1): 以 currentNode 为基准, 刚开始时在头节点, currentNode 为 head *         2): 若 currentNode 无左节点, 则向右移动 (currentNode = currentNode.left) *         3): 若 currentNode 有左节点, 则需要找到左子树上最右的节点 (mostRight) *             a: 如果 mostRight 的右指针为 null, 则让其先指向 currentNode 节点 (对应自己的祖先节点) *                 然后 currentNode 向左移动 (currentNode = currentNode.right) *             b: 如果 mostRight 的右指针为 currentNode, (之前修改过连接, 此时需要撤销之前的连接), 让其指向 null, *                 然后 currentNode 向右移动 (currentNode = currentNode.left) *         4): 循环 2,3, 直到 currentNode 为 null 时结束 */public class Marris {    static class TreeNode{        private int val;        private TreeNode left;        private TreeNode right;        TreeNode(int _val){            this.val = _val;        }    }    public static void marris(TreeNode head){        if (head == null){            return;        }        //当前来到节点        TreeNode cur = head;        //当前节点的左节点的最右节点        TreeNode mostRight;        while (cur != null){            System.out.print(cur.val + "\t");            //若 currentNode 无左节点, 则向右移动 (currentNode = currentNode.right)            if (cur.left != null){                mostRight = cur.left;                //查找当前节点的左节点的最右节点                while (mostRight.right != null && mostRight.right != cur){                    mostRight = mostRight.right;                }                //条件 a                if (mostRight.right == null){                    mostRight.right = cur;                    cur = cur.left;                } else {                    //条件 b                    mostRight.right = null;                    cur = cur.right;                }            }else {                cur = cur.right;            }        }    }    /**     * 先序打印, marris     * @param head 头结点     */    public static void preMarris(TreeNode head){        if (head == null){            return;        }        //当前来到节点        TreeNode cur = head;        //当前节点的左节点的最右节点        TreeNode mostRight;        while (cur != null){            //若 currentNode 无左节点, 则向右移动 (currentNode = currentNode.left)            if (cur.left != null){                mostRight = cur.left;                //查找当前节点的左节点的最右节点                while (mostRight.right != null && mostRight.right != cur){                    mostRight = mostRight.right;                }                //条件 a                if (mostRight.right == null){                    mostRight.right = cur;                    System.out.print(cur.val + "\t");                    cur = cur.left;                } else {                    //条件 b                    cur = cur.right;                    mostRight.right = null;                }            }else {                System.out.print(cur.val + "\t");                cur = cur.right;            }        }    }    /**     * 先序打印, marris     * @param head 头结点     */    public static void inMarris(TreeNode head){        if (head == null){            return;        }        //当前来到节点        TreeNode cur = head;        //当前节点的左节点的最右节点        TreeNode mostRight;        while (cur != null){            //若 currentNode 无左节点, 则向右移动 (currentNode = currentNode.left)            if (cur.left != null){                mostRight = cur.left;                //查找当前节点的左节点的最右节点                while (mostRight.right != null && mostRight.right != cur){                    mostRight = mostRight.right;                }                //条件 a                if (mostRight.right == null){                    mostRight.right = cur;                    cur = cur.left;                } else {                    //条件 b                    System.out.print(cur.val + "\t");                    cur = cur.right;                    mostRight.right = null;                }            }else {                System.out.print(cur.val + "\t");                cur = cur.right;            }        }    }    /**     * 先序打印, marris     * @param head 头结点     */    public static void postMarris(TreeNode head){        if (head == null){            return;        }        //当前来到节点        TreeNode cur = head;        //当前节点的左节点的最右节点        TreeNode mostRight;        while (cur != null){            //若 currentNode 无左节点, 则向右移动 (currentNode = currentNode.left)            if (cur.left != null){                mostRight = cur.left;                //查找当前节点的左节点的最右节点                while (mostRight.right != null && mostRight.right != cur){                    mostRight = mostRight.right;                }                //条件 a                if (mostRight.right == null){                    mostRight.right = cur;                    cur = cur.left;                } else {                    //将左节点的最右节点还原                    mostRight.right = null;                    //(marris遍历: 有左节点的第二次到达时记录该节点的左树右边界 (逆序 -- 链表反转法), 最后逆序单独打印整棵树的右边界)                    TreeNode reverse = reverse(cur.left);                    TreeNode temp = reverse;                    while (temp != null){                        System.out.print(temp.val + "\t");                        temp = temp.right;                    }                    reverse(reverse);                    //条件 b                    cur = cur.right;                }            }else {                cur = cur.right;            }        }        //单独逆序处理整棵树的右边界        TreeNode reverse = reverse(head);        TreeNode temp = reverse;        while (temp != null){            System.out.print(temp.val + "\t");            temp = temp.right;        }        reverse(reverse);    }    /**     * 链表的反转     * @param node 当前节点     * @return 反转后的头结点     */    private static TreeNode reverse(TreeNode node){        TreeNode pre = null;        TreeNode next = null;        while (node != null){            //记录当前节点的下一个节点            next = node.right;            //将当前节点的右指针指向前节点            node.right = pre;            //记录新的头部节点            pre = node;            //当前节点向下移动            node = next;        }        return pre;    }    public static void main(String[] args) {        TreeNode node1 = new TreeNode(1);        node1.left = new TreeNode(2);        node1.right = new TreeNode(3);        node1.left.left = new TreeNode(4);        node1.left.right = new TreeNode(5);        node1.right.left = new TreeNode(6);        node1.right.right = new TreeNode(7);        System.out.println("marris 遍历");        marris(node1);        System.out.println();        System.out.println("先序遍历");        preMarris(node1);        System.out.println();        test(node1,1);        System.out.println();        System.out.println("中序遍历");        inMarris(node1);        System.out.println();        test(node1,2);        System.out.println();        System.out.println("后序遍历");        postMarris(node1);        System.out.println();        test(node1,3);    }    public static void test(TreeNode head, int sort){        if (head == null){            return;        }        if (sort == 1){            System.out.print(head.val + "\t");            test(head.left,sort);            test(head.right,sort);        }else if (sort == 2){            test(head.left,sort);            System.out.print(head.val + "\t");            test(head.right,sort);        }else {            test(head.left,sort);            test(head.right,sort);            System.out.print(head.val + "\t");        }    }}