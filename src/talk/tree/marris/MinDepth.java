package talk.tree.marris;import com.sun.source.tree.Tree;/** * 问题: 查找一棵树的最小深度 *         给定一个二叉树，找出其最小深度。 *         最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 *             说明：叶子节点是指没有子节点的节点。 * * * *  https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/ */public class MinDepth {    static class TreeNode {        int val;        TreeNode left;        TreeNode right;        TreeNode (int _val){            this.val = _val;        }    }    /**     * 使用 marris 遍历     * @param head 头结点     * @return 最小深度     */    public static int minDepth_Marris (TreeNode head){        if (head == null){            return 0;        }        TreeNode cur = head;        TreeNode mostRight = null;        //当前节点深度        int curDepth = 0;        //最小深度        int minDepth = Integer.MAX_VALUE;        while (cur != null){            if (cur.left != null){                mostRight = cur.left;                //记录当前节点到到最右边界节点的深度                int rightNodeSize = 1;                while (mostRight.right != null && mostRight.right != cur){                    rightNodeSize++;                    mostRight = mostRight.right;                }                //该节点第一次到达                if (mostRight.right == null){                    //记录该节点的深度                    curDepth++;                    mostRight.right = cur;                    cur = cur.left;                }else {                    //第二次到达, 是否为叶子节点                    if (mostRight.left == null) {                        minDepth = Math.min(minDepth, curDepth);                    }                    //修改当前深度为其父节点的深度                    curDepth -= rightNodeSize;                    mostRight.right = null;                    cur = cur.right;                }            }else {                curDepth++;                cur = cur.right;            }        }        //单独处理整棵树的最右边界        int finalRight = 1;        cur = head;        while (cur.right != null) {            finalRight++;            cur = cur.right;        }        //如果最后节点为叶子节点        if (cur.left == null) {            minDepth = Math.min(minDepth, finalRight);        }        return minDepth;    }    public static int minDepth_Recursion (TreeNode head){        if (head == null){            return 0;        }        return process(head);    }    private static int process (TreeNode node){        //如果当前节点为叶子节点则返回        if (node.left == null && node.right == null){            return 1;        }        //记录左节点的 最小值        int minLeft = Integer.MAX_VALUE;        if (node.left != null){            minLeft = Math.min(process(node.left), minLeft);        }        //记录右边节点的最小值        int minRight = Integer.MAX_VALUE;        if (node.right != null){            minRight = Math.min(process(node.right), minLeft);        }        return 1 + Math.min(minLeft, minRight);    }    private static TreeNode generateTreeNode(int maxDepth, int maxValue){        return generateTreeNode(1,maxDepth, maxValue);    }    private static TreeNode generateTreeNode(int curDepth, int maxDepth, int maxValue){        if (curDepth > maxDepth || Math.random() > 0.5){            return null;        }        TreeNode head  = new TreeNode((int)(Math.random() * maxValue + 1));        head.left = generateTreeNode(curDepth + 1,maxDepth, maxValue);        head.right = generateTreeNode(curDepth + 1,maxDepth, maxValue);        return head;    }    public static void main(String[] args) {        int maxDepth = 10;        int maxValue = 1000;        int testTime = 10000;        System.out.println("test.....Start.....");        for (int i = 0; i < testTime; i++) {            TreeNode head = generateTreeNode(maxDepth, maxValue);            int minDepthMarris = minDepth_Marris(head);            int minDepthRecursion = minDepth_Recursion(head);            if (minDepthRecursion != minDepthMarris){                System.out.println("Marris : " + minDepthMarris);                System.out.println("Recursion : " + minDepthRecursion);                return;            }        }        System.out.println("test.....End.......");    }}