package talk.tree.marris;import java.util.ArrayList;import java.util.List;/** * 使用 marris 遍历实现 判断是否为平衡二叉树 * 条件：每一棵子树的左子树比头节点小 *                 右子树比头节点大 *      方式一：中序遍历 --》 是否一直递增 */public class IsBST {    static class TreeNode {        int val;        TreeNode left;        TreeNode right;        TreeNode (int _val){            this.val = _val;        }    }    public static boolean isBST_Marris(TreeNode head){        if (head == null){            return true;        }        TreeNode cur = head;        TreeNode mostRight = null;        int compare = Integer.MIN_VALUE;        boolean res = true;        while (cur != null) {            if (cur.left != null) {                mostRight = cur.left;                while (mostRight.right != null && mostRight.right != cur) {                    mostRight = mostRight.right;                }                //第一次到达                if (mostRight.right == null) {                    mostRight.right = cur;                    cur = cur.left;                } else {                    if (res && cur.val < compare) {                        res = false;                    } else {                        compare = cur.val;                    }                    mostRight.right = null;                    cur = cur.right;                }            } else {                //在比那里过程中实现是否 BST 的判断                if (res && cur.val < compare) {                    res = false;                } else {                    compare = cur.val;                }                cur = cur.right;            }        }        return res;    }    public static boolean test(TreeNode head){        if (head == null){            return true;        }        List<Integer> list = new ArrayList<>();        inTraversal(head,list);        for (int i = 1; i < list.size(); i++) {            if (list.get(i) <= list.get(i - 1)){                return false;            }        }        return true;    }    private static void inTraversal(TreeNode node, List<Integer> list) {        if (node == null){            return;        }        inTraversal(node.left,list);        list.add(node.val);        inTraversal(node.right,list);    }    private static TreeNode generatedTreeNode( int maxDepth, int maxValue){        return generatedTreeNode(1,maxDepth,maxValue);    }    private static TreeNode generatedTreeNode(int curDepth, int maxDepth, int maxValue){        if (curDepth > maxDepth || Math.random() > 0.5){            return null;        }        TreeNode head = new TreeNode((int)(Math.random() * maxValue + 1));        head.left = generatedTreeNode(curDepth + 1,maxDepth, maxValue);        head.right = generatedTreeNode(curDepth + 1,maxDepth, maxValue);        return head;    }    public static void main(String[] args) {        int maxValue = 1000;        int maxDepth = 10;        int testTime = 1000;        System.out.println("测试开始!");        for (int i = 0; i < testTime; i++) {            TreeNode treeNode = generatedTreeNode(maxDepth, maxValue);            if (isBST_Marris(treeNode) != test(treeNode)){                System.out.println("Oops");                return;            }        }        System.out.println("测试结束!");    }}