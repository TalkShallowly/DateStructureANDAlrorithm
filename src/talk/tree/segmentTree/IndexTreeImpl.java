package talk.tree.segmentTree;import java.util.Arrays;/** * indexTree: 实现 * *     原理: 分类管理法 (去除 0 位置) * *                         原index: 1   2    3    4     5     6     7   8    9    10 ..... *          help管理的 index 范围值: 1  1~2   3   1~4    5     5~6   7   1~8  9    9~10 ..... *                      helpIndex: 1   2    3    4     5     6     7   8    9    10 ..... * * *      特点: *          1: 只支持单点更新问题 *          2: 支持区间查询 *          3: 容易实现多维度范围查询 * *       结论一: (索引必须从 1 开始) *          若给定一个索引位置, 此处索引所管理的区域范围计算 (将二进制为最后以 1 位置的数去除,到当前为止) *              eg: index = 01101101 *                      01101100 -- 01101101 *                      01101000 -- 01101100 *                      01100000 -- 01101000 *                      01000000 -- 01100000 *                      00000000 -- 01000000 * *        结论二: *          若给定一个索引位置, 此处索引所被管理的区域范围计算 (当前索引数 到  将此索引二进制 + 最后以 1 位置的数) <= 总长度 *                 eg: index = 01101101              length = 1111111 *  *                      01101100 -- 01110000 *  *                      01110000 -- 10000000 *  *                      10000000 -- 100000000 *  * */public class IndexTreeImpl {    static class IndexTree {        private final int size;        //0 位置元素不使用        private final int[] trees;        public IndexTree(int N) {            size = N;            trees = new int[N + 1];        }        /**         * 单点更新 add         *         * @param index 位置索引         * @param value 更新值         */        public void add(int index, int value) {            if (index > 0 || index <= size){                while (index <= size) {                    trees[index] += value;                    index += (index & -index);                }            }        }        public int findRangeSum(int index) {            if (index > 0 || index <= size){                int sum = 0;                while (index > 0) {                    sum += trees[index];                    index -= (index & -index);                }                return sum;            }            return 0;        }        public int findRangeSum(int start, int end) {            if (end > start){                return findRangeSum(end) - findRangeSum(start);            }else {                return 0;            }        }    }    static class Test {        private final int size;        //0 位置元素不使用        private final int[] arr;        Test(int length) {            size = length;            arr = new int[length + 1];        }        public void add(int index, int value) {            if (index > 0 || index <= size){                arr[index] += value;            }        }        public int findRangeSum(int index) {            if (index > 0 || index <= size){                int sum = 0;                for (int i = 1; i <= index; i++) {                    sum += arr[i];                }                return sum;            }            return 0;        }        public int findRangeSum(int start, int end) {            if (end > start){                return findRangeSum(end) - findRangeSum(start);            }else {                return 0;            }        }    }    public static void main(String[] args) {        int length = 1000000;        int maxValue = 100000;        int testCount = 1000;        IndexTree indexTree = new IndexTree(length);        Test test = new Test(length);        for (int i = 0; i < testCount; i++) {            double random = Math.random();            if (random < 0.4) {                int value = (int) (Math.random() * maxValue);                int index = (int) (Math.random() * length);                indexTree.add(index, value);                test.add(index,value);            } else if (random < 0.7){                int findIndex = (int) (Math.random() * length);                int indexTreeRangeSum = indexTree.findRangeSum(findIndex);                int testRangeSum = test.findRangeSum(findIndex);                if (indexTreeRangeSum != testRangeSum) {                    System.out.println("test : " + testRangeSum + " -- sum : " + indexTreeRangeSum);                    return;                }            }else {                int start = 0, end = 0;                while (end <= start){                    start = (int) (Math.random() * length);                    end = (int) (Math.random() * length);                }                int indexTreeRangeSum = indexTree.findRangeSum(start,end);                int testRangeSum = test.findRangeSum(start,end);                if (indexTreeRangeSum != testRangeSum) {                    System.out.println("test : " + testRangeSum + " -- sum : " + indexTreeRangeSum);                    return;                }            }        }    }}