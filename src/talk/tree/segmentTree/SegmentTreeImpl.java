package talk.tree.segmentTree;import java.util.Arrays;/** * 线段树: 最大区间的对应计算 *      eg:  原数据长度: {0 ~~ 999} *         add : 在 3 ~ 450 区间每个数增加 x *         update : 在 500 ~ 560 区间每个数据更新为 y *         sum: 计算 200 ~ 600 区间的统计和 z * *      线段树实现: 规定原数据下标从 1 位置开始 即 {1 ~ 1000} * *          第一步: 申请一个 sum 数组, 小标从 1 开始, {a,b,c,d,e,f,g,h} *               作用:                        {a: 1 ~ 1000} *                       {b: 1 ~ 500}                               {c: 501 ~ 1000} *           {d: 1 ~ 250}           {e: 251 ~ 500}    {f: 501 ~ 750}               {g: 751 ~ 1000} * *            即为sum 每个索引小标记录一个区间统计和, 形成一个树形结构 * *   sum 数组长度问题: 因为 sum 数据是一个树型结构, 假设原数据长度为 N, 是 2 的整数倍, 则满足满二叉树的特性 (叶子节点为 N,非叶子节点为 n - 1) , *      如果最低层节点多出一到两个, 因为 sum是根据位置进行的索引计算, 需要在此申请全部层级空间, 上一层节点的 2 倍, 即 N + (N - 1) + 2N = 4N 为最大空间 * * *       add() 方法: 使用懒更新策略  (申请一个 4N 长度的数组 lazy 来记录每一区间的添加值) * *          假设:  {3 ~ 100, 4} *              步骤一: 给定一个计算区间 和 添加区间 *                  添加区间 是否 全包含计算区间 *                     是: 先将此区间的 sum 数组中的值进行更新 (有对应的区间索引), lazy (对应的区间索引) 记录新添加的数据 (累加: 可能有原来的更新) * *                     否: *                          1): 先判断计算区间是否懒更新记录, 有,先下发, (计算下一次 sum 和下一层的 lazy 值) *                          2): 将计算区间分割左右区间, 递归计算 * *        update()方法 : 同样使用懒维护策略 (申请一个 4N 长度的boolean 数组 update 和 记录数据 change 来记录每一区间的更新值) *              update 和 change 区分原因: 如果某个区间更新为 0 , 则无法进行判断 * *                  步骤: 给定一个计算区间 和 更新区间 *                    更新区间 是否 全包含计算区间 *  *                     是: 先将此区间的 sum 数组中的值进行更新 (有对应的区间索引), update 和 change  (对应的区间索引) 联合记录更新的数据,  如果有 lazy 需要清空 * *                        否: *                          1): 先判断计算区间是否更新记录, 有,先下发, (计算下一层 sum 和下一层的 change 值, 同时情空下一层 lazy) *                          2): 将计算区间分割左右区间, 递归计算 * * */public class SegmentTreeImpl {    static class SegmentTree {        //原数据处理后的最大长度        private final int maxLen;        // arr[]为原序列的信息从0开始，但在arr里是从1开始的        private final int[] array;        // sum[]模拟线段树维护区间和        private final int[] sum;        // change[]为更新的值        private final int[] change;        // lazy[]为累加和懒惰标记        private final int[] lazy;        // update[]为更新慵懒标记        private final boolean[] update;        //初始化参数        public SegmentTree(int[] origin){            maxLen = origin.length + 1;            array = new int[maxLen];            for (int i = 1; i < maxLen; i++) {                array[i] = origin[i - 1];            }            sum = new int[maxLen << 2];            change = new int[maxLen << 2];            lazy = new int[maxLen << 2];            update = new boolean[maxLen << 2];            //先构建 sum 树            build(1, maxLen - 1, 1);        }        public void build(int left, int right, int index){            if (left == right) {                sum[index] = array[left];                return;            }            int mid = left + ((right - left) >> 1);            build(left, mid, index << 1);            build(mid + 1, right,index << 1 | 1);            //自底向上调整            pushUp(index);        }        /**         * 自底向上调整 sum 值         */        private void pushUp(int index){            sum[index] = sum[index << 1] + sum[index << 1 | 1];        }        /**         * 自顶向下调整:  之前的，所有懒增加，和懒更新，从父范围，发给左右两个子范围         *         分发策略是什么         *          leftNum表示左子树元素结点个数，rightNum表示右子树结点个数         * @param index 当前区间索引         * @param leftNum 左节点个数         * @param rightNum 右节点个数         */        private void pushDown(int index, int leftNum, int rightNum){            //如果有更新, 先更新,            if (update[index]){                //更新下发                update[index << 1] = true;                update[index << 1 | 1] = true;                //更新参数下发                change[index << 1] = change[index];                change[index << 1 | 1] = change[index];                //添加记录记为 0                lazy[index << 1] = 0;                lazy[index << 1 | 1] = 0;                //计算下发的 sum和                sum[index << 1] = change[index] * leftNum;                sum[index << 1 | 1] = change[index] * rightNum;                //重新设置更新标志                update[index] = false;            }            if (lazy[index] != 0) {                //懒加载下发累加                lazy[index << 1] += lazy[index];                lazy[index << 1 | 1] += lazy[index];                //数组和下发                sum[index << 1] = lazy[index] * leftNum;                sum[index << 1 | 1] += lazy[index] * rightNum;                lazy[index] = 0;            }        }        /**         * 添加 left ~ right 所有增加 value         * @param left 左边界         * @param right 有边界         * @param value 添加值         */        public void add(int left, int right, int value){            add(1, maxLen - 1, left, right, 1, value);        }        /**         * 添加         * @param curLeft 当前来到的左边界         * @param curRight 当前来到的右边界         * @param originLeft 原来的左边界         * @param originRight 原来的右边界         * @param index 当前来到的索引值         * @param value 添加值         */        private void add(int curLeft, int curRight, int originLeft, int originRight, int index, int value){            //如果原来的左右边界全包含当前的左右边界            if (originLeft <= curLeft && originRight >= curRight){                //更新计算区间和                sum[index] += value * (curRight - curLeft + 1);                //懒标记累加                lazy[index] += value;                return;            }            int mid = curLeft + ((curRight - curLeft) >> 1);            //向下调整: 是否有过懒标记和更新标记            pushDown(index, mid - curLeft + 1, curRight - mid);            //当前中间值是否被 originLeft 覆盖着            if (originLeft <= mid){                add(curLeft, mid, originLeft, originRight, index << 1, value);            }            if (originRight > mid){                add(mid + 1, curRight, originLeft, originRight, index << 1 | 1, value);            }            //向上调整: 计算当前 sum和            pushUp(index);        }        /**         * 更新 left ~ right 所有值更新至 value         * @param left 左边界         * @param right 有边界         * @param value 添加值         */        public void update(int left, int right, int value){            update(1, maxLen - 1, left, right, 1, value);        }        /**         * 更新         * @param curLeft 当前来到的左边界         * @param curRight 当前来到的右边界         * @param originLeft 原来的左边界         * @param originRight 原来的右边界         * @param index 当前来到的索引值         * @param value 添加值         */        private void update(int curLeft, int curRight, int originLeft, int originRight, int index, int value){            //如果原来的左右边界全包含当前的左右边界 (更新 update 标记, change 更新值, 初始化 lazy)            if (originLeft <= curLeft && originRight >= curRight) {                update[index] = true;                sum[index] = value * (curRight - curLeft + 1);                change[index] = value;                lazy[index] = 0;                return;            }            int mid = curLeft + ((curRight - curLeft) >> 1);            //向下调整: 是否有过懒标记和更新标记 (当前任务躲不掉，无法懒更新，要往下发)            pushDown(index, mid - curLeft + 1, curRight - mid);            if (originLeft <= mid){                update(curLeft, mid, originLeft, originRight, index << 1, value);            }            if (originRight > mid){                update(mid + 1, curRight, originLeft, originRight, index << 1 | 1, value);            }            pushUp(index);        }        /**         * 查询区间和         * @param left 左边区间         * @param right 右边区间         * @return 区间和         */        public long queryRangeSum(int left, int right){            return calculateSum(1, maxLen - 1,left, right, 1);        }        /**         * 查询区间和         * @param curLeft 当前来到的左边界         * @param curRight 当前来到的右边界         * @param originLeft 原来的左边界         * @param originRight 原来的右边界         * @param index 当前来到的索引值         * @return  区间和         */        private long calculateSum(int curLeft, int curRight, int originLeft, int originRight, int index) {            //全包含: 返回区间和            if (originLeft <= curLeft && originRight >= curRight) {                return sum[index];            }            int mid = curLeft + ((curRight - curLeft) >> 1);            //向下调整            pushDown(index, mid - curLeft + 1, curRight - mid);            long ans = 0;            if (originLeft <= mid){                ans += calculateSum(curLeft, mid, originLeft, originRight, index << 1);            }            if (originRight > mid){                ans += calculateSum(mid + 1, curRight, originLeft, originRight, index << 1 | 1);            }            return ans;        }    }    static class Right {        private final int[] arr;        public Right(int[] origin) {            arr = new int[origin.length + 1];            for (int i = 0; i < origin.length; i++) {                arr[i + 1] = origin[i];            }        }        public void add(int left, int right, int value){            for (int i = left; i <= right; i++) {                arr[i] += value;            }        }        public void update(int left, int right, int value){            for (int i = left; i <= right; i++) {                arr[i] = value;            }        }        public long query(int left, int right){            int sum = 0;            for (int i = left; i <= right; i++) {                sum += arr[i];            }            return sum;        }    }    public static int[] generateRandomArray(int maxLen, int maxValue){        int len = (int)(Math.random() * maxLen) + 1;        int[] origin = new int[len];        for (int i = 0; i < len; i++) {            origin[i] = (int)(Math.random() * maxValue) + 1;        }        return origin;    }    public static void test() {        int maxLen = 1000;        int maxValue = 1000;        int testTime = 10000;        System.out.println("测试开始.....");        for (int i = 0; i < testTime; i++) {            int[] array = generateRandomArray(maxLen, maxValue);            int len = array.length;            SegmentTree segmentTree = new SegmentTree(array);            Right test = new Right(array);            int right = -1;            int left = 0;            while (left > right) {                 right = (int)(Math.random() * len) + 1;                 left = (int)(Math.random() * len) + 1;            }            int value = (int)(Math.random() * maxValue) + 1;            for (int i1 = 0; i1 < 10; i1++) {                if (Math.random() < 0.6){                    segmentTree.add(left, right, value);                    test.add(left, right, value);//                System.out.println("left : " + left + " right : " + right + " Add : " + value);                }else {                    segmentTree.update(left, right, value);                    test.update(left, right, value);//                System.out.println("left : " + left + " right : " + right + " Update : " + value);                }            }            long queryRangeSum = segmentTree.queryRangeSum(left, right);            long query = test.query(left, right);            if (query != queryRangeSum){                System.out.println(Arrays.toString(array));                System.out.println("query : " + query + " ----  queryRangeSum : " + queryRangeSum);                return;            }        }        System.out.println("测试结束......");    }    public static void main(String[] args) {        int[] origin = { 10, 9, 8, 8, 1};        SegmentTree seg = new SegmentTree(origin);        Right right = new Right(origin);        int L = 1; // 操作区间的开始位置 -> 可变        int R = 4; // 操作区间的结束位置 -> 可变        int C = 1; // 要加的数字或者要更新的数字 -> 可变        // 区间生成，必须在[S,N]整个范围上build//        seg.build(S, N, root);        // 区间修改，可以改变L、R和C的值，其他值不可改变//        seg.add(L, R, C, S, N, root);        seg.add(L, R, C);        right.add(L, R, C);        // 区间更新，可以改变L、R和C的值，其他值不可改变//        seg.update(L, R, C, S, N, root);//        seg.update(L, R, C);//        right.update(L, R, C);//         区间查询，可以改变L和R的值，其他值不可改变        long sum = seg.queryRangeSum(L, R);        long query = right.query(L, R);//        System.out.println(sum);//        System.out.println(query);//        System.out.println("对数器测试开始...");//        System.out.println("测试结果 : " + (test() ? "通过" : "未通过"));        test();    }}