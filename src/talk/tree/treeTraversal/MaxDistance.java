package talk.tree.treeTraversal;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;/** * 给定一个二叉树的头节点head，任何两个节点之间都存在距离，求整棵二叉树的最大距离 *    要求：返回一颗二叉树任意两个节点之间的最大距离 *      节点信息可能性分析： *          X左树的最大距离 *          X右树的最大距离 *          X左树与X最远（树的高度问题） + X右树与X最远 （右树高度） */public class MaxDistance {    public static class TreeNode {        private TreeNode leftNode;        private TreeNode rightNode;        private int data;        TreeNode(int _value) {            this.data = _value;        }    }    /**     * 需要的节点信息     * 1；树的高度     * 2: 节点间的最大距离     */    public static class NodeInfo {        private int height;        private int maxDistance;        NodeInfo(int _height, int _maxDistance) {            this.height = _height;            this.maxDistance = _maxDistance;        }    }    public static int maxDistance_01(TreeNode head) {        if (head == null) {            return 0;        }        ArrayList<TreeNode> arr = getPrelist(head);        HashMap<TreeNode, TreeNode> parentMap = getParentMap(head);        int max = 0;        for (int i = 0; i < arr.size(); i++) {            for (int j = i; j < arr.size(); j++) {                max = Math.max(max, distance(parentMap, arr.get(i), arr.get(j)));            }        }        return max;    }    public static ArrayList<TreeNode> getPrelist(TreeNode head) {        ArrayList<TreeNode> arr = new ArrayList<>();        fillPrelist(head, arr);        return arr;    }    public static void fillPrelist(TreeNode head, ArrayList<TreeNode> arr) {        if (head == null) {            return;        }        arr.add(head);        fillPrelist(head.leftNode, arr);        fillPrelist(head.rightNode, arr);    }    public static HashMap<TreeNode, TreeNode> getParentMap(TreeNode head) {        HashMap<TreeNode, TreeNode> map = new HashMap<>();        map.put(head, null);        fillParentMap(head, map);        return map;    }    public static void fillParentMap(TreeNode head, HashMap<TreeNode, TreeNode> parentMap) {        if (head.leftNode != null) {            parentMap.put(head.leftNode, head);            fillParentMap(head.leftNode, parentMap);        }        if (head.rightNode != null) {            parentMap.put(head.rightNode, head);            fillParentMap(head.rightNode, parentMap);        }    }    public static int distance(HashMap<TreeNode, TreeNode> parentMap, TreeNode o1, TreeNode o2) {        HashSet<TreeNode> o1Set = new HashSet<>();        TreeNode cur = o1;        o1Set.add(cur);        while (parentMap.get(cur) != null) {            cur = parentMap.get(cur);            o1Set.add(cur);        }        cur = o2;        while (!o1Set.contains(cur)) {            cur = parentMap.get(cur);        }        TreeNode lowestAncestor = cur;        cur = o1;        int distance1 = 1;        while (cur != lowestAncestor) {            cur = parentMap.get(cur);            distance1++;        }        cur = o2;        int distance2 = 1;        while (cur != lowestAncestor) {            cur = parentMap.get(cur);            distance2++;        }        return distance1 + distance2 - 1;    }    public static int maxDistance_02(TreeNode root) {        if (root == null) {            return 0;        }        return process_02(root).maxDistance;    }    private static NodeInfo process_02(TreeNode node) {        if (node == null) {            return new NodeInfo(0, 0);        }        NodeInfo left = process_02(node.leftNode);        NodeInfo right = process_02(node.rightNode);        int height = Math.max(left.height, right.height) + 1;        int maxDistance = Math.max(Math.max(left.maxDistance, right.maxDistance), left.height + right.height + 1);        return new NodeInfo(height, maxDistance);    }    public static TreeNode generateRandomTree(int maxLevel, int maxValue) {        return generate(1, maxLevel, maxValue);    }    public static TreeNode generate(int level, int maxLevel, int maxValue) {        if (level > maxLevel || Math.random() > 0.5) {            return null;        }        TreeNode root = new TreeNode((int) (Math.random() * maxValue) + 1);        root.leftNode = generate(level + 1, maxLevel, (int) (Math.random() * maxValue) + 1);        root.rightNode = generate(level + 1, maxLevel, (int) (Math.random() * maxValue) + 1);        return root;    }    public static TreeNode testInstance() {        TreeNode root = new TreeNode(1);        root.leftNode = new TreeNode(2);        root.rightNode = new TreeNode(3);        root.leftNode.leftNode = new TreeNode(4);        root.leftNode.rightNode = new TreeNode(5);        root.rightNode.leftNode = new TreeNode(6);        root.rightNode.rightNode = new TreeNode(7);        return root;    }    public static void main(String[] args) {        int maxLevel = 8;        int maxValue = 1000;        int testCount = 10000;        System.out.println("Start...........");        for (int i = 0; i < testCount; i++) {            TreeNode root = generateRandomTree(maxLevel, maxValue);            if (maxDistance_01(root) != maxDistance_02(root)){                System.out.println("Oops ");            }        }        System.out.println("Finish...........");//        System.out.println(maxDistance_01(testInstance()));//        System.out.println("---------------------");//        System.out.println(maxDistance_02(testInstance()));    }}