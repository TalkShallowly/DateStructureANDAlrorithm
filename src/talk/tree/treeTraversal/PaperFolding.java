package talk.tree.treeTraversal;/** * 折纸游戏：一张纸可以进行无限次的折叠，但是每一次折叠之后展开都会出现两种折痕， 凹折痕，凸折痕， *          用纸张由下向上面对自己进行折叠，折叠N次后，从上向下以此打印折痕 * *    折叠展开现象：二叉树规则 -》 1：根节点为凹折痕 *                             2：左树头节点 全部为凹折痕 *                             3：右树头节点 全部为凸折痕 */public class PaperFolding {    public static void printFolding(int N){        if (N <= 0){            return;        }        process(1,N,true);    }    /**     * 当前你来了一个节点，脑海中想象的！     * 这个节点在第i层，一共有N层，N固定不变的     * 这个节点如果是凹的话，isConcave = T     * 这个节点如果是凸的话，isConcave = F     * 函数的功能：中序打印以你想象的节点为头的整棵树     *     * @param curNum 当前层数     * @param N 指定层数     * @param isConcave 是否为凹节点     */    private static void process(int curNum, int N,boolean isConcave){        if (curNum > N){            return;        }        process(curNum + 1, N,true);        System.out.print(isConcave ? "凹" : "凸");        System.out.print("\t");        process(curNum + 1, N,false);    }    public static void main(String[] args) {        int count = 2;        printFolding(count);    }}