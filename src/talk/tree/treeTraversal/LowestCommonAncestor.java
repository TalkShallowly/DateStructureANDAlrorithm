package talk.tree.treeTraversal;/** *  二叉树的最近公共祖先问题： *  测试地址： https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/ *     题目： 给定一颗二叉树的头节点head，和另外两个节点 a 和 b,返回a和 b 的最低公共祖先 * *          第一种: 使用索引表,将其中一条链路的父节点全部放入 set 中,并在map 结构中维护每个节点的父节点 * *          第二种: 使用递归套路: 两种情况: *              1: 以 X 节点为头结点时,汇聚点与其有关(三种情况) *                  a: X == a 节点时, X 的左右树发现 b 节点 *                  b: X == b 节点时, X 的左右树发现 a 节点 *                  c: X 的左树发现 a 或者 b , 右树发现 b 或者 a *              2: 汇聚点与 X 无关 () *                  a: a 和 b 节点找到一个,没找全 *                  b: X 不是最低汇聚节点 *                  c: X 的左树有答案 *                  d: X 的右树有答案 * *              可能性信息: *                  1: 是否发现 a 节点 *                  2: 是否发现 b 节点 *                  3: 最低祖先节点 * */public class LowestCommonAncestor {    public static class TreeNode {        private TreeNode left;        private TreeNode right;        private int value;        TreeNode(int _value) {            this.value = _value;        }    }    public static class NodeInfo{        private boolean isFind_A;        private boolean isFind_B;        private TreeNode lowestCommonAncestorNode;        NodeInfo(boolean _isFind_A, boolean _isFind_B, TreeNode _lowestCommonAncestorNode){            this.isFind_A = _isFind_A;            this.isFind_B = _isFind_B;            this.lowestCommonAncestorNode = _lowestCommonAncestorNode;        }    }    public static TreeNode lowestCommonAncestor_02(TreeNode root, TreeNode a, TreeNode b){        if (root == null){            return null;        }        return process_02(root,a,b).lowestCommonAncestorNode;    }    private static NodeInfo process_02(TreeNode node, TreeNode a, TreeNode b){        if (node == null){            return new NodeInfo(false, false,null);        }        NodeInfo leftInfo = process_02(node.left,a,b);        NodeInfo rightInfo = process_02(node.right,a,b);        boolean isFind_A = leftInfo.isFind_A || rightInfo.isFind_A || node == a;        boolean isFind_B = leftInfo.isFind_B || rightInfo.isFind_B || node == b;        TreeNode lowestCommonAncestorNode = null;        if (isFind_A && isFind_B){            lowestCommonAncestorNode = node;        }        lowestCommonAncestorNode = leftInfo.lowestCommonAncestorNode != null ? leftInfo.lowestCommonAncestorNode :                rightInfo.lowestCommonAncestorNode != null ? rightInfo.lowestCommonAncestorNode : lowestCommonAncestorNode;        return new NodeInfo(isFind_A,isFind_B,lowestCommonAncestorNode);    }}