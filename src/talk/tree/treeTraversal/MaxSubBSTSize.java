package talk.tree.treeTraversal;import java.util.ArrayList;/** * 题目：以 X 为头的整棵树的子树是SearchTree时，返回其最大节点数量的子树 *    分析：1： 以 X 作为根节点的时候，整棵树都是 Search Tree *         2： 不以 X 作为根节点的时候， 返回其最大子树为 Search Tree 的节点数量 * *    可能性分析： *          1： 当 X 为根节点：                        2 : 当 X 不为根节点 *               a : 左树为BST                             a : 左树最大的子树BST的Size *               b : 右树为BST                             b : 右树最大的子树BST的Size *               c : 左树的最大值 < X *               d : 右树的最小值 > X */public class MaxSubBSTSize {    public static class TreeNode {        private TreeNode leftNode;        private TreeNode rightNode;        private int data;        TreeNode(int _value) {            this.data = _value;        }    }    public static int maxSubBSTSize_01(TreeNode head) {        if (head == null) {            return 0;        }        int h = getBSTSize(head);        if (h != 0) {            return h;        }        return Math.max(maxSubBSTSize_01(head.leftNode), maxSubBSTSize_01(head.rightNode));    }    private static int getBSTSize(TreeNode head) {        if (head == null) {            return 0;        }        ArrayList<TreeNode> arr = new ArrayList<>();        in(head, arr);        for (int i = 1; i < arr.size(); i++) {            if (arr.get(i).data <= arr.get(i - 1).data) {                return 0;            }        }        return arr.size();    }    // 为了验证    // 对数器方法    public static void in(TreeNode head, ArrayList<TreeNode> arr) {        if (head == null) {            return;        }        in(head.leftNode, arr);        arr.add(head);        in(head.rightNode, arr);    }    public static class NodeInfo{        private boolean isBST;        private int maxValue;        private int minValue;        private int maxBSTSize;        NodeInfo(boolean _isBST, int _maxValue, int _minValue,int _maxBSTSize){            this.minValue = _minValue;            this.maxValue = _maxValue;            this.isBST = _isBST;            this.maxBSTSize = _maxBSTSize;        }    }    public static int maxSubBSTSize_02(TreeNode root){        if (root == null){            return 0;        }        return process_02(root).maxBSTSize;    }    private static NodeInfo process_02(TreeNode node){        if (node == null){            return null;        }        NodeInfo left = process_02(node.leftNode);        NodeInfo right = process_02(node.rightNode);        int minValue = node.data;        int maxValue = node.data;        boolean isBST = true;        int maxBSTSize = 1;        if (left != null){            if (left.maxValue >= maxValue || !left.isBST){                isBST = false;            }            maxBSTSize = left.isBST && isBST ? left.maxBSTSize + 1 : Math.max(maxBSTSize,left.maxBSTSize);        }        if (right != null){            if (right.minValue <= minValue || !right.isBST){                isBST = false;            }            if (left == null){                maxBSTSize = right.isBST && isBST ? right.maxBSTSize + 1 : Math.max(maxBSTSize,right.maxBSTSize);            }else {                maxBSTSize = isBST ? left.maxBSTSize + right.maxBSTSize + 1 : Math.max(left.maxBSTSize, right.maxBSTSize);            }        }        //此处判读为了获取节点的 最大/最小值        if (left != null && right != null){            minValue = Math.min(Math.min(minValue, left.minValue), right.minValue);            maxValue = Math.max(Math.max(maxValue, left.maxValue), right.maxValue);        }else if (left != null){            minValue = Math.min(minValue,left.minValue);            maxValue = Math.max(maxValue, left.maxValue);        }else {            if (right != null){                maxValue = Math.max(maxValue,right.maxValue);                minValue = Math.min(minValue, right.minValue);            }        }        return new NodeInfo(isBST,maxValue,minValue,maxBSTSize);    }    // 对数器方法    public static TreeNode generateRandomBST(int maxLevel, int maxValue) {        return generate(1, maxLevel, maxValue);    }    // 为了验证    // 对数器方法    public static TreeNode generate(int level, int maxLevel, int maxValue) {        if (level > maxLevel || Math.random() < 0.5) {            return null;        }        TreeNode head = new TreeNode((int) (Math.random() * maxValue));        head.leftNode = generate(level + 1, maxLevel, maxValue);        head.rightNode = generate(level + 1, maxLevel, maxValue);        return head;    }    public static TreeNode testInstance(){        TreeNode root = new TreeNode(1);        root.leftNode = new TreeNode(2);        root.rightNode = new TreeNode(3);//        root.leftNode.leftNode = new TreeNode(2);//        root.leftNode.rightNode = new TreeNode(4);        root.rightNode.leftNode = new TreeNode(5);//        root.rightNode.rightNode = new TreeNode(6);        root.rightNode.leftNode.leftNode = new TreeNode(4);        return root;    }    public static void main(String[] args) {//        int maxSubBSTSize = maxSubBSTSize_01(testInstance());//        int maxSubBSTSize_02 = maxSubBSTSize_02(testInstance());//        System.out.println(" maxSubBSTSize =  " + maxSubBSTSize);//        System.out.println(" maxSubBSTSize_02 =  " + maxSubBSTSize_02);        int maxLevel = 8;        int maxValue = 100;        int testTimes = 100000;        System.out.println("测试开始");        for (int i = 0; i < testTimes; i++) {            TreeNode head = generateRandomBST(maxLevel, maxValue);            if (maxSubBSTSize_01(head) != maxSubBSTSize_02(head)) {                System.out.println("Oops。。。。");                System.out.println(maxSubBSTSize_01(head));                System.out.println(maxSubBSTSize_02(head));                System.out.println("========");            }        }        System.out.println("测试结束");    }}