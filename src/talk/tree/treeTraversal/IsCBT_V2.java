package talk.tree.treeTraversal;import java.util.LinkedList;import java.util.Queue;/** * 判断一棵树以X为头的二叉树是否为完全二叉树 ： *      第一种方法： 按层遍历 *      第二种方式： 递归套路：-- 节点信息法 *           以下为不满足完全二叉树的几种可能性 *          *    1: 左树为满二叉树,右树为满二叉树  --> 左右高度相等 : 整棵树为满二叉树 *          *    2: 左树为完全二叉树,右树为满二叉树  ---> 左树高度 = 右树高度 + 1 *          *    3: 左树为满二叉树,右树为满二叉树  ----> 左树高度 = 右树高度 + 1 *          *    4: 左树为满二叉树,右树为完全二叉树  ----> 左树高度 = 右树高度 * */public class IsCBT_V2 {    public static class TreeNode{        private TreeNode leftNode;        private TreeNode rightNode;        private int value;        TreeNode(int _value){            this.value = _value;        }    }    public static boolean isCBT_01(TreeNode root){        if (root == null){            return true;        }        return levelTraversal(root);    }    private static boolean levelTraversal(TreeNode node){        Queue<TreeNode> queue = new LinkedList<>();        queue.add(node);        boolean signal = false;        while (!queue.isEmpty()){            TreeNode poll = queue.poll();            /*             * 先将信号量设置为 false ,如果遇到以下几种情况             *      1: 如果没有左节点,但是有右节点的情况             *      2: 右节点为 null,但是左节点有叶子节点的情况             */            if ((signal && (poll.leftNode != null || poll.rightNode != null)) || (poll.leftNode == null && poll.rightNode != null)){                return false;            }            if (poll.leftNode != null){                queue.add(poll.leftNode);            }            if (poll.rightNode != null){                queue.add(poll.rightNode);            }            if (poll.leftNode == null || poll.rightNode == null){                signal = true;            }        }        return true;    }    public static class NodeInfo{        private boolean isCBT;        private boolean isFull;        private int height;        NodeInfo(boolean _isCBT, boolean _isFull, int _height){            this.isCBT = _isCBT;            this.isFull = _isFull;            this.height = _height;        }    }    public static boolean isCBT_02(TreeNode root){        if (root == null){            return true;        }        return process(root).isCBT;    }    private static NodeInfo process(TreeNode node){        if (node == null){            return new NodeInfo(true, true,0);        }        NodeInfo leftInfo = process(node.leftNode);        NodeInfo rightInfo = process(node.rightNode);        boolean isFull = leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height;        int height = Math.max(leftInfo.height, rightInfo.height) + 1;        /**         * 以下为不满足完全二叉树的几种可能性         *    1: 左树为满二叉树,右树为满二叉树  --> 左右高度相等 : 整棵树为满二叉树         *    2: 左树为完全二叉树,右树为满二叉树  ---> 左树高度 = 右树高度 + 1         *    3: 左树为满二叉树,右树为满二叉树  ----> 左树高度 = 右树高度 + 1         *    4: 左树为满二叉树,右树为完全二叉树  ----> 左树高度 = 右树高度         */        boolean isCBT = false;        if (leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height){            isCBT = true;        }        if (leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height + 1){            isCBT = true;        }        if (leftInfo.isCBT && rightInfo.isFull && leftInfo.height == rightInfo.height + 1){            isCBT = true;        }        if (leftInfo.isFull && rightInfo.isCBT && leftInfo.height == rightInfo.height){            isCBT = true;        }        return new NodeInfo(isCBT,isFull,height);    }    /**     * 生成随机节点     * @param maxLevel 最大层级     * @param maxValue 最大数值     * @return 随机节点     */    public static TreeNode generateRandomNode(int maxLevel,int maxValue){        return generate(1,maxLevel,maxValue);    }    public static TreeNode generate(int level,int maxLevel,int maxValue){        if (level > maxLevel || Math.random() > 0.5){            return null;        }        TreeNode node= new TreeNode((int)(Math.random() * maxValue + 1));        node.leftNode = generate(level + 1, maxLevel,maxValue);        node.rightNode = generate(level + 1, maxLevel,maxValue);        return node;    }    public static void main(String[] args) {        int maxLevel = 8;        int maxValue = 10000;        int testTime = 1000000;        System.out.println("Start,.......");        for (int i = 0; i < testTime; i++) {            TreeNode root = generateRandomNode(maxLevel, maxValue);            if (isCBT_01(root) != isCBT_02(root)){                System.out.println("Oops");            }        }        System.out.println("Finish.......");    }}