package talk.monotonous_stack;import java.util.Arrays;import java.util.Stack;/** * 子矩阵计数问题： *      给定一个二维数组 matrix, 其中的值不是 0 就是 1, 返回全部由 1 组成的子矩阵数量 * *  测试链接：https://leetcode.com/problems/count-submatrices-with-all-ones */public class CountSubMatricesWithAllOnes {    public static int numSubmat(int[][] matrix){        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){            return 0;        }        int count = monotonousStack(matrix[0]);        for (int i = 1; i < matrix.length; i++) {            for (int k = 0; k < matrix[i].length; k++) {                matrix[i][k] = matrix[i][k] == 0 ? 0 : matrix[i][k] + matrix[i - 1][k];            }            count += monotonousStack(matrix[i]);        }        return count;    }    // 比如    //              1    //              1    //              1         1    //    1         1         1    //    1         1         1    //    1         1         1    //    //    2  ....   6   ....  9    // 如上图，假设在6位置，1的高度为6    // 在6位置的左边，离6位置最近、且小于高度6的位置是2，2位置的高度是3    // 在6位置的右边，离6位置最近、且小于高度6的位置是9，9位置的高度是4    // 此时需要求的范围    // 1) 求在3~8范围上，必须以高度6作为高的矩形，有几个？    // 2) 求在3~8范围上，必须以高度5作为高的矩形，有几个？    // 也就是说，<=4的高度，一律不求    // 那么，1) 求必须以位置6的高度6作为高的矩形，有几个？    // 3..3  3..4  3..5  3..6  3..7  3..8    // 4..4  4..5  4..6  4..7  4..8    // 5..5  5..6  5..7  5..8    // 6..6  6..7  6..8    // 7..7  7..8    // 8..8    // 这么多！= 21 = (9 - 2 - 1) * (9 - 2) / 2    // 这就是任何一个数字从栈里弹出的时候，计算矩形数量的方式    private static int monotonousStack(int[] arr){        int[] stack = new int[arr.length];        int size = 0;//        Stack<Integer> stack = new Stack<>();        int count = 0;        for (int i = 0; i < arr.length; i++) {            while (size != 0 && arr[stack[size - 1]] > arr[i]){                int pop = stack[--size];                if (arr[pop] > arr[i]){                    //计算左边的小于值                    int left = size == 0 ? -1 : stack[size - 1];                    //计算长度                    int len = i - left - 1;                    //计算最左和最右边的最大值                    int down = Math.max(left == -1 ? 0 : arr[left], arr[i]);                    count += (arr[pop] - down) * num(len);                }            }            stack[size++] = i;        }        while (size != 0){            int pop = stack[--size];                int left = size == 0 ? -1 : stack[size - 1];                int len = arr.length - left - 1;                int down = left == -1 ? 0 : arr[left];                count += (arr[pop] - down) * num(len);        }        return count;    }    /**     * 前 n 项和公式     */    public static int num(int n) {        return ((n * (1 + n)) >> 1);    }    public static void main(String[] args) {        int[][] arr = {{1,1,1,1,0,1,0},{1,1,1,0,0,0,1},{0,1,1,1,1,0,0},{1,1,0,1,1,0,1},{1,0,0,0,0,0,1},{1,1,0,1,1,1,1},{1,1,0,0,1,1,1}};////        int[][] arr = {{1,0,1},{1,1,0},{1,1,0}} ;////        int[][] arr = {{0,1,1,0},{0,1,1,1},{1,1,1,0}};//        System.out.println(numSubmat(arr));//        System.out.println("====================");//        System.out.println(test(arr));//        int[] ints = {3, 1, 0, 1, 1, 1, 3};//        System.out.println(monotonousStack(ints));    }}