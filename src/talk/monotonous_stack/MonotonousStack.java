package talk.monotonous_stack;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Stack;/** * 单调栈: *      解释: *         对于数组 arr[] ,计算以数组 arr[] 中每一个数为标准, 计算该输左右两边距离最近的大/小值, 进而进行统计 * *         eg: arr{2,3,5,2,1,4} * *         其中以 5 为标准, *                  左边最近比 5 小的数为 3 *                  右边最近比 5 小的数为 2 * * *      对于数组求解 */public class MonotonousStack {    static class Info {        private final int leftMin, rightMin;        @Override        public String toString() {            return "Info{" +                    "leftMin=" + leftMin +                    ", rightMin=" + rightMin +                    '}';        }        Info(int leftMin, int rightMin) {            this.leftMin = leftMin;            this.rightMin = rightMin;        }    }        public static Info[] monotonousStack(int[] arr){        Info[] res = new Info[arr.length];        Stack<LinkedList<Integer>> stack = new Stack<>();        for (int i = 0; i < arr.length; i++) {            if (stack.isEmpty() || arr[stack.peek().getLast()] < arr[i]){                LinkedList<Integer> list = new LinkedList<>();                list.addLast(i);                stack.add(list);            }else if (arr[stack.peek().getLast()] == arr[i]){                stack.peek().addLast(i);            }else {                do {                    LinkedList<Integer> pop = stack.pop();                    int leftMin = stack.isEmpty() ? -1 : stack.peek().getLast();                    while (!pop.isEmpty()){                        res[pop.pollLast()] = new Info(leftMin, i);;                    }                } while (!stack.isEmpty() && arr[stack.peek().getLast()] > arr[i]);                if (!stack.isEmpty() && arr[stack.peek().getLast()] == arr[i]){                    stack.peek().addLast(i);                }else {                    LinkedList<Integer> list = new LinkedList<>();                    list.addLast(i);                    stack.add(list);                }            }        }        while (!stack.isEmpty()){            LinkedList<Integer> pop = stack.pop();            int leftMin= stack.isEmpty() ? -1 : stack.peek().getLast();            while (!pop.isEmpty()){                res[pop.pollLast()] = new Info(leftMin, -1);;            }        }        return res;    }    private static int[][] monotonousStack2(int[] arr){        int[][] record = new int[arr.length][2];        Stack<List<Integer>> stack = new Stack<>();        for (int i = 0; i < arr.length; i++) {            //当前数据如果比之前添加的数组 小, 则需要从栈中弹出统计            while  (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]){                List<Integer> pop = stack.pop();                int leftMin = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);                for (Integer j : pop){                    record[j][0] = leftMin;                    record[j][1] = i;                }            }            //如果大于之前的数据, 则直接添加即可            if (stack.isEmpty() || arr[stack.peek().get(0)] < arr[i]){                List<Integer> list = new ArrayList<>();                list.add(i);                stack.add(list);            }else {                stack.peek().add(i);            }        }        //将栈中剩余的数据进行统计        while (!stack.isEmpty()){            List<Integer> pop = stack.pop();            int leftMin = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);            for (Integer j : pop){                record[j][0] = leftMin;                record[j][1] = -1;            }        }        return record;    }    private static int[] generateRandomArray(int maxLen, int maxVal){        int len = (int)(Math.random() * maxLen) + 1;        int[] arr = new int[len];        for (int i = 0; i < arr.length; i++) {            arr[i] = (int)(Math.random() * maxVal) + 1;        }        return arr;    }    public static void main(String[] args) {//        int[] arr = {2,3,5,2,1,4};//        int index = 0;//        for (Info info : monotonousStack(arr)) {//            System.out.println("第 " + index + " 信息 : " + info.toString());//            index++;//        }        int maxLen = 1000;        int maxVal = 1000;        int timeCount = 10000;        System.out.println("测试开始!");        for (int i = 0; i < timeCount; i++) {            int[] ints = generateRandomArray(maxLen, maxVal);            Info[] infos = monotonousStack(ints);            int[][] arr = monotonousStack2(ints);            for (int j = 0; j < arr.length; j++) {                if (arr[j][0] != infos[j].leftMin && arr[j][1] != infos[j].rightMin){                    System.out.println("Oops");                    return;                }            }        }        System.out.println("测试结束!");    }}