package talk.monotonous_stack.fibonacci;import java.util.Arrays;/** * 斐波那契数列问题 : *      常规算法: 递归计算每一值 时间复杂度 O(N) *      优化算法: 使用行列式 时间复杂度 O(logN) * *         eg: 1, 1, 2, 3, 5, 8, 13, 21 ..... *              公式 N = (N - 1) + (N - 2) *              因为此公式为二阶方程, 最低阶为 2 *              故此满足线性代数矩阵方程: *                                              |a, b|^(n - 2)   (n = 3) *                  |F(3),F(2)| = |F(2),F(1)| * |c, d| *                                                           |a, b|^(n - 2)     某个二阶矩阵的 (N - 2)^2 *                  以此可推出 |F(N),F(N - 1)| = |F(2),F(1)| * |c, d| * *                  因此只需要计算 二阶矩阵的 N - 2 次方即可, 使用二分法计算 时间复杂度 O(logN) *                     二分法:  eg: 10^75   (利用二进制位数计算) *                                  75 (01001011) = 64 + 8 + 2 + 1 = 2^6 + 2^3 + 2^1 + 2^0 = * * * */public class FibonacciProblem {    public static void main(String[] args) {        int[][] a = {{1,1},                     {1,2}};        int[][] b = {{1,1},                     {0,1}};//        System.out.println(Arrays.deepToString(matrixMultiply(a, b)));        System.out.println(fibonacci_matrix(32));        System.out.println(fibonacci_recursion(32));        System.out.println(fibonacci_cycle(32));    }    /**     * 菲波那切数计算结果 : 矩阵实现 (时间复杂度 O(logN))     * @param num 第 n 项     * @return 第 n 项结果     */    public static int fibonacci_matrix(int num){        if (num < 1){            return 0;        }        if (num == 1 || num == 2){            return 1;        }        // 定义第一项与第二项的数据        int firstItem = 1;        int secondItem = 1;        //计算的二维矩阵        int[][] matrix = {{1,1},                          {1,0}};        int[][] function = function(matrix, num - 2);        return function[0][0] + function[1][0];    }    /**     * 二进制位计算矩阵次方     * @param matrix 矩阵     * @param power 次方     * @return a^b     */    private static int[][] function(int[][] matrix, int power){        //单位矩阵 : 矩阵中的 1        int[][] res = new int[matrix.length][matrix[0].length];        for (int i = 0; i < matrix.length; i++) {            res[i][i] = 1;        }        //当前矩阵的一次方        int[][] record = matrix;        while (power != 0){            if ((power & 1) != 0){                //当前位的计算结果:  matrixMultiply(res, record) 中的 res 存放的是之前计算的结果, record记录当前位置的结果                res = matrixMultiply(res, record);            }            //同时计算出下一位的结果            record = matrixMultiply(record, record);            power >>= 1;        }        return res;    }    /**     * 斐波那契数列计算 : 递归实现 (时间复杂度: O(N))     * @param num 第 n 项     * @return 第 n 项结果     */    public static int fibonacci_recursion(int num){        if (num < 1){            return 0;        }        if (num == 1 || num == 2){            return 1;        }        // 定义第一项与第二项的数据        return process(num);    }    private static int process(int n){        if (n == 1 || n == 2){            return 1;        }        if (n == 3){            return 2;        }        int res = 0;        res += process(n - 1) +  process(n - 2);        return res;    }    /**     * 斐波那契数列计算: 循环实现     * @param num 第 n 项     * @return 第 n 项结果     */    public static int fibonacci_cycle(int num){        if (num < 1){            return 0;        }        if (num == 1 || num == 2){            return 1;        }        int res = 0;        int preItem = 1;        int preTwoItem = 1;        for (int i = 3; i <= num; i++) {            res = preItem + preTwoItem;            preTwoItem = preItem;            preItem = res;        }        return res;    }    /**     * 两个矩阵相乘 (同行同列矩阵)     *      |a, b|      |e, f|      |ae + bg, af + bh|     *      |c, d|  *   |g, h|  =   |ce + dg, cf + dh|     * @param a  矩阵     * @param b  矩阵     * @return 乘积矩阵     */    private static int[][] matrixMultiply(int[][] a, int[][] b){        int row = a.length;        int col = b[0].length;        int[][] res = new int[row][col];        for (int i = 0; i < row; i++) {            for (int j = 0; j < col; j++) {                for (int k = 0; k < a[0].length; k++) {                    res[i][j] += a[i][k] * b[k][j];                }            }        }        return res;    }    /**     * 二进制位计算次方 (二分法: 时间复杂度 : O(logN))     * @param a 计算底数     * @param b 次方     * @return a^b     */    private static int function(int a, int b){        if (b == 1){            return a;        }        return (int) ((b & 1) == 0 ? Math.pow(function(a, b >> 1), 2) :  Math.pow(function(a, b >> 1), 2) * a);    }}