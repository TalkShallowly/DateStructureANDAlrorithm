package talk.monotonous_stack.fibonacci;import java.util.Arrays;/** * 问题: *      有一个牛场, 第一年农场有 1 只成熟的母牛, 往后的每年 *          1) : 每一只母牛都会产生一只母牛 *          2) : 每一只新出生的母牛都会在出生的第三年成熟 *          3) : 每一只母牛永远不会死亡 * *       返回 N 年后牛的数量 * *       公式: f(n) = f(n - 1) + f(n - 3) * *             扩展:每一只牛在第四年的时候死去 *                      公式: f(n) = f(n - 1) + f(n - 3) - f(n - 4) */public class N_YearCow {    public static long cowNum(int N){        if (N < 0){            return 0;        }else if (N == 1){            return 1;        }else if (N == 2){            return 2;        }else if (N == 3){            return 3;        }else {            long[][] matrix = {{1,1,0},                              {0,0,1},                              {1,0,0}};            long[] preItem = {1,2,3};            long[][] ints = process_matrix(N - 3, matrix);            return preItem[2] * ints[0][0] +  preItem[1] * ints[1][0] +  preItem[0] * ints[2][0];        }    }    /**     * 计算给定矩阵的 n 次方     * @param N 次方     * @param matrix 矩阵     * @return 计算结果     */    private static long[][] process_matrix(long N,  long[][] matrix){        long[][] res = new long[matrix.length][matrix[0].length];        for (int i = 0; i < matrix.length; i++) {            res[i][i] = 1;        }        long[][] record = matrix;        while (N != 0){            if ((N & 1) != 0){                res = matrixMultiply(res,record);            }            record = matrixMultiply(record,record);            N >>= 1;        }        return res;    }    /**     * 两矩阵相乘     * @param matrix1 矩阵 1     * @param matrix2 矩阵 2     * @return 矩阵     */    private static long[][] matrixMultiply(long[][] matrix1, long[][] matrix2){        int row = matrix1.length;        int col = matrix2[0].length;        long[][] res = new long[row][col];        for (int i = 0; i < row; i++) {            for (int j = 0; j < col; j++) {                for (int k = 0; k < matrix1[0].length; k++) {                    res[i][j] += matrix1[i][k] * matrix2[k][j];                }            }        }        return res;    }    public static long cowNum2(int N){        if (N < 0){            return 0;        }else if (N == 1){            return 1;        }else if (N == 2){            return 2;        }else if (N == 3){            return 3;        }else {            long firstItem = 1;            long twoItem = 2;            long threeItem = 3;            for (int i = 4; i < N; i++) {                long curSum = threeItem + firstItem;                firstItem = twoItem;                twoItem =  threeItem;                threeItem = curSum;            }            return threeItem + firstItem;        }    }    public static long cowNum3(int N){        if (N < 0){            return 0;        }        return process(N);    }    public static long process(int N){        if (N == 1){            return 1;        }else if (N == 2){            return 2;        }else if (N == 3){            return 3;        }else {            return process(N - 1) + process(N - 3);        }    }    public static void main(String[] args) {        int N = 1000;        int testCount = 1000;        long t1  = 0;        long t2 = 0;        for (int i = 0; i < testCount; i++) {            int num = (int)(Math.random() * 100) + 1;            long start = System.currentTimeMillis();            for (int k = 0; k < testCount; k++) {                cowNum(num);            }            long end = System.currentTimeMillis();            long end2 = System.currentTimeMillis();            for (int k = 0; k < testCount; k++) {                cowNum2(num);            }            long end3 = System.currentTimeMillis();            t1 += (end - start);            t1 += (end3 - end2);        }//        long start = System.currentTimeMillis();//        long cowNum = cowNum(N);//        long end = System.currentTimeMillis();//        long cowNum2 = cowNum2(N);//        long end2 = System.currentTimeMillis();////        long cowNum3 = cowNum3(N);//        long end3 = System.currentTimeMillis();        System.out.println("矩阵 结果 : " + 0 + " -- 耗时: " + t1);        System.out.println("循环 结果 : " + 0 + " -- 耗时: " + t2);//        System.out.println("递归 结果 : " + cowNum3 + " -- 耗时: " + (end3 - end2));//        System.out.println(cowNum(N));//        System.out.println();//        System.out.println(cowNum3(N));//        int[][] matrix = {{1,1,0},//                {0,0,1},//                {1,0,0}};//        System.out.println(Arrays.deepToString(matrixMultiply(matrix,matrix)));    }}