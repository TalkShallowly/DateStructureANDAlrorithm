package talk.monotonous_stack.fibonacci;import java.util.Arrays;/** * 问题: 给定一个数 N , 想象只有 1 和 0 两种字符组成的所有长度为 N 的字符串, 如果某个字符串的 任意 *  0 字符的左边都有 1 紧挨着, 认为这个字符串达标, 返回有多少达标的字符串 * *      定义一个 f 函数, 作用如下: *        在以下的 剩余的 个格子中填写 0 和 1 的合格数量 * *        判断合格数: *          若是 第 N 项填写 1 , 则无论 第 N - 1 填写 0 或者 1 都是合格的,  因此依赖 F(N - 1) *          若是 第 N 项填写 0 , 则第 N - 1 必须为 1, 第 N - 2 填写 0 或者 1 都是合格的,  因此依赖 F(N - 2) *          所以: f(N) = f(N - 1) + f(N - 2) */public class ZeroLeftOneStringNumber {    public static long zeroLeftOneStringNumber(int N){        if (N <= 0){            return 0;        }else if (N == 1){            return 1;        }else if (N == 2){            return 2;        }else {            long[][] matrix = {{1,1},                    {1,0}};            long[][] process = process(N - 2, matrix);            return 2 * process[0][0] + process[1][0];        }    }    private static long[][] process(int N, long[][] matrix){        long[][] res = new long[matrix.length][matrix[0].length];        for (int i = 0; i < matrix.length; i++) {            res[i][i] = 1;        }        long[][] record = matrix;        while (N != 0){            if ((N & 1) != 0){                res = matrixMultiply(record,res);            }            record = matrixMultiply(record,record);            N >>= 1;        }        return res;    }    private static long[][] matrixMultiply(long[][] a, long[][] b){        int row = a.length;        int col = b[0].length;        long[][] res = new long[row][col];        for (int i = 0; i < row; i++) {            for (int j = 0; j < col; j++) {                for (int k = 0; k < a[0].length; k++) {                    res[i][j] += a[i][k] * b[k][j];                }            }        }        return res;    }    public static long test(int N){        if (N <= 0){            return 0;        }else if (N == 1){            return 1;        }else if (N == 2){            return 2;        }else {            long first = 1;            long second = 2;            for (int i = 3; i < N; i++) {                long res = first + second;                first = second;                second = res;            }            return first + second;        }    }    public static void main(String[] args) {        System.out.println(zeroLeftOneStringNumber(20));        System.out.println(test(20));        long[][] matrix = {{1,1},                {1,0}};        System.out.println(Arrays.deepToString(matrixMultiply(matrix, matrix)));    }}