package talk.monotonous_stack;import java.util.Stack;/** * 单调栈问题: *      给定一个包含正数的数组 arr[], 其中 arr[] 中 *          任意一个子数组 sub[] 都可以算出(sub[] 累加和) * (sub[] 中最小值), *              求所有子数组 (累加和与最小值相乘) 的最大值 * * * 一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。 * 比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。 * 给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。 * 请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。 * 子数组 定义为一个数组的 连续 部分。 * * 测试链接 : https://leetcode.com/problems/maximum-subarray-min-product/ * *          优化: 使用数组栈代替系统栈 */public class AllTimesMinToMax {//    public static int max1(int[] arr) {//        int max = Integer.MIN_VALUE;//        for (int i = 0; i < arr.length; i++) {//            for (int j = i; j < arr.length; j++) {//                int minNum = Integer.MAX_VALUE;//                int sum = 0;//                for (int k = i; k <= j; k++) {//                    sum += arr[k];//                    minNum = Math.min(minNum, arr[k]);//                }//                max = Math.max(max, minNum * sum);//            }//        }//        return max;//    }    public static int maxSumMinProduct(int[] arr){        if (arr == null || arr.length == 0){            return 0;        }        int N = arr.length;        //计算数组累加和        long[] sum = new long[N];        sum[0] = arr[0];        for (int i = 1; i < N; i++) {            sum[i] = sum[i - 1] + arr[i];        }        long res = 0;        for (int i = 0; i < N; i++) {            for (int j = i; j < N; j++) {                int minValue = arr[i];                for (int k = i; k <= j; k++) {                    minValue = Math.min(minValue,arr[k]);                }                res = Math.max(res, minValue * (sum[j] - (i == 0 ? 0 : sum[i - 1])));            }        }        return (int)res;//        return (int)(res % 1000000007);    }    /**     * 单调栈实现 --- 使用系统栈     * @param arr 目标数组     * @return 子数组最大累加和     */    public static int maxSumMinProduct1(int[] arr){         if (arr == null || arr.length == 0){             return 0;         }         int N = arr.length;         //计算数组累加和         long[] sum = new long[N];         sum[0] = arr[0];         for (int i = 1; i < N; i++) {             sum[i] = sum[i - 1] + arr[i];         }         long res = 0;         int curIndex = 0;         Stack<Integer> stack = new Stack<>();         for (int L = 0; L < N; L++) {             //如果栈不是空, 此处如果值相同则从栈中弹出计算, 后面相同的数据进栈, 进行下一轮的计算             while (!stack.isEmpty() && arr[stack.peek()] >= arr[L]) {                 curIndex = stack.pop();                 long subSum = sum[L - 1] - (stack.isEmpty() ? 0 : sum[stack.peek()]);                 res = Math.max(res, (subSum *  arr[curIndex]));             }             if (stack.isEmpty() || arr[stack.peek()] <= arr[L]) {                 stack.add(L);             }         }         while (!stack.isEmpty()){             curIndex = stack.pop();             long subSum = sum[N - 1] - (stack.isEmpty() ? 0 : sum[ stack.peek()]);             res = Math.max(res, (subSum * arr[curIndex]));         }//         return (int) (res % 1000000007);        return (int)res;     }    /**     * 优化: 使用数组栈,代替系统栈     * @param arr 目标数组     * @return Min(子数组 * 最小值)     */    public static int maxSumMinProduct2(int[] arr){        if (arr == null || arr.length == 0){            return 0;        }        int N = arr.length;        long[] sum = new long[N];        sum[0] = arr[0];        for (int i = 1; i < N; i++) {            sum[i] = sum[i - 1] + arr[i];        }        long res = 0;        int curIndex = 0;        int size = 0;        int[] stack = new int[N];//        Stack<Integer> stack = new Stack<>();        for (int L = 0; L < N; L++) {            while (size != 0 && arr[stack[size - 1]] >= arr[L]) {                curIndex = stack[--size];                long subSum = sum[L - 1] - (size == 0 ? 0 : sum[stack[size - 1]]);                res = Math.max(res, (subSum *  arr[curIndex]));            }            if (size == 0 || arr[stack[size - 1]] <= arr[L]) {                stack[size++] = L;            }        }        while (size != 0){            curIndex = stack[--size];            long subSum = sum[N - 1] - (size == 0 ? 0 : sum[stack[size - 1]]);            res = Math.max(res, (subSum * arr[curIndex]));        }        return (int) (res % 1000000007);    }    private static int[] generateRandomArray(int maxLen, int maxValue) {        int len = (int) (Math.random() * maxLen) + 1;        int[] ints = new int[len];        for (int i = 0; i < len; i++) {            ints[i] = (int) (Math.random() * maxValue) + 1;        }        return ints;    }    public static void main(String[] args) {        int maxLen = 100;        int maxValue = 100;        int timeCount = 1000;        System.out.println("测试开始!");        for (int i = 0; i < timeCount; i++) {            int[] ints = generateRandomArray(maxLen, maxValue);            int i1 = maxSumMinProduct(ints);            int i2 = maxSumMinProduct1(ints);            int i3 = maxSumMinProduct2(ints);            if (i1 != i2){                System.out.println("Oops");            }        }        System.out.println("测试结束!");//        int[] arr = {2,3,3,1};//        System.out.println(maxSumMinProduct(arr));    }}