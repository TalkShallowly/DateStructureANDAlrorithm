package talk.bfprt;import java.util.Comparator;import java.util.PriorityQueue;/** * * 问题: 给定一个无序数组 arr[] 和 一个正数 K, 返回前 K 个最大的数 (K < N) *      实现: 不同时间复杂度的三种方法 *        1): O(N * logN) ---->> 直接排序取最后 K 个 *        2): O(N + (K * logN))  --->> 使用怼结构 * * * * * bfprt 算法: 用于在无序数组求第 K 小的数 * *    类似于随机快排, 但是随机快排的 每次标数选择不确定, * *    bfprt: 对于 [标数] 的选择比较严格 * *      解释: *          1): 将长度为 len 的原数组分为每组 N 个数 (一般 N 为 3,5,7), 这里选择 5 *          2): 对每组数据进行怕排序 *          3): 将排序后的每组数的中位数组合为一个新的数组 M排序, 长度为 len / N *          4): 再获取 M 中的中位数, 即为选定的 P, 索引位置在于 len / 2N 位置 * *                那么在数组 M 中 >= P 的数为 len / 2N 个, 则对应在分组数组每个 >= P 的数,就会多出两 (len / 2N) * 2 个 *                一共有 ((2 * len) / 2N) + (len / 2N) = 3len / 2N * *                N = 5, 即原数组中 < P 的数为  7len / 10, 在于 K 做对比, (每次过滤 3/10 的数据量) * *          eg: 原数据 {a, b, c, d, e, f, g, h, i ,j, k, l, m, n, o, p, q, r,s, t, u, v, w, x , y ,z}  len = 27 * *          第一组: {a ,b ,c ,d ,e} *          第二组: {f ,g ,h ,i ,j} *          第三组: {k ,l ,n ,m ,n} *          第四组: {o ,p ,q ,r ,s} *          第五组: {t ,u ,v ,w ,x} *          第六组: {y, z} * *          中心数组M : {c, h , n ,q, v, y}  其中 n 的位置为 len / 2N, >= n 的数据有 (len / N) - (len / 2N) * *            >= n 的数据 q, v, y , 没一个对应在分组数组就会多出两个 >= n 的数, 一共有 3len / 2N 个 * *          核心: 每次递归都会过滤 3len / 2N 的数据量 , 7len / 2N 为最大数据量 * *          最终时间复杂度: T(N) = T(len / 5) + T (7N / 10) + O(N) */public class FindMinKth {    //定义一个比较器    static class MaxHeadComparator implements Comparator<Integer> {        @Override        public int compare(Integer o1, Integer o2) {            return o2 - o1;        }    }    /**     * 方式一: 查询第 K 小的数  使用堆结构 (大根堆)  时间复杂度: O(N*logK) 空间复杂度 O(K)     * @param arr 当前数组     * @param kIndex k 值索引     * @return 第 K 小的数     */    public static int minKth1(int[] arr, int kIndex){        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new MaxHeadComparator());        //先在堆中加入 K 个数        for (int i = 0; i < kIndex; i++) {            maxHeap.add(arr[i]);        }        //因为是大根堆, 在依次加入剩下的数,        for (int i = kIndex; i < arr.length; i++) {            //如果加入的数据小于当前堆顶的元素, 则将对顶元素弹出, 并将当前元素添加进堆中            if (maxHeap.isEmpty()){                System.out.println(kIndex);            }            if (arr[i] < maxHeap.peek()) {                maxHeap.poll();                maxHeap.add(arr[i]);            }        }        return maxHeap.peek();    }    /**     * 方式二 : 随机快排模式 : 时间复杂度: O(N*logN) 空间复杂度 O(K)     * @param ints 当前数组     * @param K K     * @return 第 K 小的数     */    public static int minKth2(int[] ints, int K){        int[] arr = copyArray(ints);        return process(arr, 0, arr.length - 1, K - 1);    }    // arr 第k小的数    // process2(arr, 0, N-1, k-1)    // arr[L..R]  范围上，如果排序的话(不是真的去排序)，找位于index的数    // index [L..R]    private static int process(int[] arr, int start, int end, int kIndex){        if (start == end){            return arr[start];        }        //确定随机数        int pivot = arr[start + (int) (Math.random() * (end - start + 1))];        int[] partition = partition(arr, start, end, pivot);        if (kIndex >= partition[0] && kIndex <= partition[1]){            return arr[kIndex];        }else if (kIndex < partition[0]){            return process(arr, start, partition[0] - 1, kIndex);        }else {            return process(arr, partition[1] + 1, end, kIndex);        }    }    private static int[] partition(int[] arr, int start, int end, int pivot){        //左边界        int leftBorder = start - 1;        //右边界        int rightBorder = end + 1;        int index = start;        //当前索引位置不能和右边界相交        while (index < rightBorder){            if (arr[index] < pivot){                swap(arr, ++leftBorder, index++);            }else if (arr[index] > pivot){                swap(arr, index, --rightBorder);            }else {                index++;            }        }        return new int[]{leftBorder + 1 ,rightBorder - 1};    }    //数据拷贝    public static int[] copyArray(int[] arr){        int[] ints = new int[arr.length];        for (int i = 0; i < arr.length; i++) {            ints[i] = arr[i];        }        return ints;    }    // 利用bfprt算法，时间复杂度O(N)    public static int minKth3(int[] ints, int K){        int[] arr = copyArray(ints);        return bfprt(arr, 0, arr.length - 1, K - 1);    }    private static int bfprt(int[] arr, int start, int end, int kIndex){        if (start == end){            return arr[start];        }        // L...R  每五个数一组        // 每一个小组内部排好序        // 小组的中位数组成新数组        // 这个新数组的中位数返回        int pivot = medianOfMedians(arr, start, end);        //剩余过程与快排一致        int[] partition = partition(arr, start, end, pivot);        if (kIndex >= partition[0] && kIndex <= partition[1]){            return arr[kIndex];        }else if (kIndex < partition[0]){            return bfprt(arr, start, partition[0] - 1, kIndex);        }else {            return bfprt(arr, partition[1] + 1, end, kIndex);        }    }    // L...R  每五个数一组    // 每一个小组内部排好序    // 小组的中位数组成新数组    // 这个新数组的中位数返回    private static int medianOfMedians(int[] arr, int start, int end){        //计算当前长度值        int size = end - start + 1;        //是否可以进行完全拆分        int offset = size % 5 == 0 ? 0 : 1;        //每个数据的中位数,需保存在当前数组中        int[] mArr = new int[size / 5 + offset];        for (int i = 0; i < mArr.length; i++) {            int tempFirst = start + i * 5;            mArr[i] = getMedian(arr, tempFirst, Math.min((tempFirst + 4), end));        }        //对取出的中位数在进行排序操作        insertSort(mArr, 0, mArr.length - 1);        //获取新数组中的中位数        return mArr[mArr.length / 2];    }    //获取数组的中位数    private static int getMedian(int[] arr,int start, int end){        insertSort(arr, start, end);        return arr[(start + end) / 2];    }    //使用插入排序进行比较    private static void insertSort(int[] arr, int start, int end){        for (int i = start + 1; i <= end; i++) {            for (int j = i - 1; j >= start && arr[j] > arr[j + 1]; j--) {                swap(arr, j, j + 1);            }        }    }    /**     * 快排解法一: 荷兰国旗问题 (单边界)     */    public static int quickSort_1(int[] arr, int left, int right, int kValue){        if (left >= right){            return left;        }        int process = process(arr, left, right);        if (kValue > arr[process]){            quickSort_1(arr, process + 1, right, kValue);        }else if (kValue < arr[process]){            quickSort_1(arr, left, process - 1, kValue);        }else {            return arr[process - 1];        }        return 1;    }    private static int process(int[] arr, int start, int end){        if (start == end){            return start;        }        //定义一个左边界, 初始位置为开始索引位置 - 1        int leftBorder = start - 1;        int index = start;        while (index < end){            if (arr[index] <= arr[end]){                swap(arr, index, ++leftBorder);            }            index++;        }        swap(arr, ++leftBorder, end);        return leftBorder;    }    /**     * 快排解法二: 荷兰国旗问题 (双边界)     */    public static void quickSort_2(int[] arr, int left, int right){        if (left >= right){            return;        }        int[] process = process2(arr, left, right);        quickSort_2(arr, left, process[0]);        quickSort_2(arr, process[1] , right);    }    private static int[] process2(int[] arr, int start, int end){        if (start == end){            return new int[]{start,end};        }        //定义一个左边界, 初始位置为开始索引位置 - 1        int leftBorder = start - 1;        //定义一个左边界, 初始位置为结束索引位置        int rightBorder = end;        int index = start;        //(当前位置不能和左边界相遇)        while (index < rightBorder){            if (arr[index] < arr[end]){                swap(arr, index++, ++leftBorder);            }else {                //与右边界数据交换的时候,需要都交换过来的数据进行再次比较                swap(arr, index, --rightBorder);            }        }        //当前 索引位置和 右边界是相等的, 中间剩余的位置后续不在比较        swap(arr, rightBorder, end);        //当前左边界, 去除比较的 [基数]        return new int[]{leftBorder, rightBorder + 1};    }    /**     * 快排解法三: 荷兰国旗问题 (双边界) + 随机快排     */    public static void quickSort_3(int[] arr, int left, int right){        if (left >= right){            return;        }        int[] process = process3(arr, left, right);        quickSort_3(arr, left, process[0]);        quickSort_3(arr, process[1] , right);    }    private static int[] process3(int[] arr, int start, int end){        if (start == end){            return new int[]{start,end};        }        //定义一个左边界, 初始位置为开始索引位置 - 1        int leftBorder = start - 1;        //定义一个左边界, 初始位置为结束索引位置        int rightBorder = end;        int index = start;        //(当前位置不能和左边界相遇)        //定义随机数        int sentinel = (int)(Math.random() * (end - start - 1)) + start;        swap(arr, sentinel, end);        while (index < rightBorder){            if (arr[index] < arr[end]){                swap(arr, index++, ++leftBorder);            }else {                //与右边界数据交换的时候,需要都交换过来的数据进行再次比较                swap(arr, index, --rightBorder);            }        }        //当前 索引位置和 右边界是相等的, 中间剩余的位置后续不在比较        swap(arr, rightBorder, end);        //当前左边界, 去除比较的 [基数]        return new int[]{leftBorder, rightBorder + 1};    }    private static void swap(int[] arr, int x, int  y) {        int temp = arr[x];        arr[x] = arr[y];        arr[y] = temp;    }    public static int[] generateRandomArray(int maxLen, int maxValue){        int len = (int)(Math.random() * maxLen) + 1;        int[] arr = new int[len];        for (int i = 0; i < arr.length; i++) {            arr[i] = (int)(Math.random() * maxValue) + 1;        }        return arr;    }    public static void main(String[] args) {        int maxLen = 1000;        int maxValue = 10000;        int testCount = 10000;        System.out.println("test.......... Start .......");        for (int i = 0; i < testCount; i++) {            int[] array = generateRandomArray(maxLen, maxValue);            int k = (int)(Math.random() * (array.length - 1)) + 1;            int headMethod = minKth1(array, k);            int quickSort = minKth2(array, k);            int bfprt = minKth3(array, k);            if (headMethod != quickSort && bfprt != quickSort && bfprt != headMethod){                System.out.println("Oops");                return;            }        }        System.out.println("test........... End .........");//        int[] arr = {7, 10, 4, 3, 20, 15};//        System.out.println(minKth1(arr, 3));//        System.out.println(minKth2(arr, 3));//        System.out.println(minKth3(arr, 3));    }}