package talk.union_find;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Stack;/** * 题目: 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 *   岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 * * 此外，你可以假设该网格的四条边均被水包围。 * * 来源：力扣（LeetCode） * 链接：https://leetcode.cn/problems/number-of-islands * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class NumberOfIsLands {    /**     * 解题方式一: 感染法     *      -- 只要在矩阵中有一个位置出现 1,则对其中上下左右相邻的位置为 1 的全部替换为 0     */    public int numIslands_01(char[][] grid) {        int ans = 0;        for (int i = 0; i < grid.length; i++) {            for (int j = 0; j < grid[0].length; j++) {                if (grid[i][j] == '1'){                    infect(grid,i,j);                    ans ++;                }            }        }        return ans;    }    /**     * 递归感染: 让其相邻位置属于 1 的字符全部进行替换     */    private static void infect(char[][] board, int i, int j){        if (i < 0 || i == board.length || j < 0 || j == board[0].length || board[i][j] != '1'){            return;        }        board[i][j] = 0;        //上下左右一次查找替换        infect(board,i - 1,j);        infect(board,i + 1,j);        infect(board,i,j + 1);        infect(board,i,j - 1);    }    /**     * 解决方式二: 使用数组并查集     */    public int numIslands_02(char[][] grid) {        int row = grid.length;        int col = grid[0].length;        UnionSet_Array unionSetArray = new UnionSet_Array(grid);        //处理第一行数据        for (int i = 1; i < col; i++) {            if (grid[0][i - 1] == '1' && grid[0][i] == '1'){                unionSetArray.union(0,i-1,0,i);            }        }        //处理第一列数据        for (int i = 1; i < row; i++) {            if (grid[i- 1][0] == '1' && grid[i][0] == '1'){                unionSetArray.union(i-1,0,i,0);            }        }        //处理剩余数据        for (int i = 1; i < row; i++) {            for (int j = 1; j < col; j++) {                if (grid[i- 1][j] == '1' && grid[i][j] == '1'){                    unionSetArray.union(i-1,j,i,j);                }                if (grid[i][j - 1] == '1' && grid[i][j] == '1'){                    unionSetArray.union(i,j-1,i,j);                }            }        }        return unionSetArray.count;    }    public static class UnionSet_Array{        private final int[] parents;        private final int[] size;        private final int[] help;        private int count;        private final int col;        UnionSet_Array(char[][] board){            int row = board.length;            this.col = board[0].length;            int length = row * col;            parents = new int[length];            size = new int[length];            help = new int[length];            count = 0;            for (int i = 0; i < row; i++) {                for (int j = 0; j < col; j++) {                    if (board[i][j] == '1'){                        int index = i * col + j;                        parents[index] = index;                        size[i] = 1;                        count++;                    }                }            }        }        public int findFather(int m){            int parent = parents[m];            int i = 0;            while (m != parent){                help[i++] = m;                m = parent;                parent = parents[m];            }            while (i > 0){                parents[help[--i]] = parent;            }            return parent;        }        private int indexValue(int curRow, int curCol){            return curRow * col + curCol;        }        public void  union(int curRow_01, int curCol_01, int curRow_02, int curCol_02) {            int o1 = indexValue(curRow_01,curCol_01);            int o2 =indexValue(curRow_02,curCol_02);            int father_o1 = findFather(o1);            int father_o2 = findFather(o2);            if (father_o1 != father_o2){                int big  = size[father_o1] >= size[father_o2] ? father_o1 : father_o2;                int small = big == father_o1 ? father_o2 : father_o1;                parents[small] = big;                size[big] = size[father_o1] + size[father_o2];                count--;            }        }        public int sets(){            return count;        }    }    /**     * 解决方式三: 使用 hashMap 并查集     */    public int numIslands_03(char[][] grid) {        int row = grid.length;        int col = grid[0].length;        List<Transform> list = new ArrayList<>();        //此处需要再次包装一层.将基本数据类型转为引用类型        Transform[][] transforms = new Transform[row][col];        for (int i = 0; i < row; i++) {            for (int j = 0; j < col; j++) {                if (grid[i][j] == '1'){                    transforms[i][j] = new Transform();                    list.add(transforms[i][j]);                }            }        }        UnionSet_Map<Transform> unionSetMap = new UnionSet_Map<>(list);        //处理第一行数据        for (int i = 1; i < col; i++) {            if (grid[0][i - 1] == '1' && grid[0][i] == '1'){                unionSetMap.union(transforms[0][i - 1],transforms[0][i]);            }        }        //处理第一列数据        for (int i = 1; i < row; i++) {            if (grid[i - 1][0] == '1' && grid[i][0] == '1'){                unionSetMap.union(transforms[i - 1][0],transforms[i][0]);            }        }        //处理剩余数据        for (int i = 1; i < row; i++) {            for (int j = 1; j < col; j++) {                if (grid[i - 1][j] == '1' && grid[i][j] == '1') {                    unionSetMap.union(transforms[i - 1][j], transforms[i][j]);                }                if (grid[i][j - 1] == '1' && grid[i][j] == '1'){                    unionSetMap.union(transforms[i][j - 1], transforms[i][j]);                }            }        }        return unionSetMap.count();    }    /**     * 用于将基本类型数据进行包装     */    public static class Transform{};    /**     * 封装节点信息     * @param <V>     */    public static class Node<V>{        private final V value;        Node(V _value){           this.value = _value;        }    }    public static class UnionSet_Map<V> {        private final HashMap<V, Node<V>> nodes;        private final HashMap<Node<V>, Node<V>> parents;        private final HashMap<Node<V>, Integer> sizeMap;        UnionSet_Map(List<V> values) {            nodes = new HashMap<>();            parents = new HashMap<>();            sizeMap = new HashMap<>();            for (V cur : values) {                Node<V> node = new Node<>(cur);                nodes.put(cur, node);                parents.put(node, node);                sizeMap.put(node, 1);            }        }        public Node<V> findFather(V value) {            Node<V> curNode = nodes.get(value);            Stack<Node<V>> stack = new Stack<>();            Node<V> parent = parents.get(curNode);            while (curNode != parent) {                curNode = parent;                parent = parents.get(curNode);                stack.push(curNode);            }            while (!stack.isEmpty()) {                parents.put(stack.pop(), parent);            }            return parent;        }        public void union(V o1, V o2) {            Node<V> father_o1 = findFather(o1);            Node<V> father_o2 = findFather(o2);            if (father_o1 != father_o2) {                Node<V> bigNode = sizeMap.get(father_o1) >= sizeMap.get(father_o2) ? father_o1 : father_o2;                Node<V> smallNode = bigNode == father_o1 ? father_o2 : father_o1;                parents.put(smallNode, bigNode);                sizeMap.put(smallNode, sizeMap.get(father_o1) + sizeMap.get(father_o2));                sizeMap.remove(smallNode);            }        }        public int count(){            return sizeMap.size();        }    }    public static void main(String[] args) {        char[][] chars = new char[1][2];        chars[0][0] = 1;        chars[0][1] = 2;        System.out.println(chars.length);        System.out.println(chars[0].length);    }    }