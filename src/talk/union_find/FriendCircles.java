package talk.union_find;/** * 题目: 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 *      省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 * *      给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 * * 返回矩阵中 省份 的数量 * * 来源：力扣（LetCode） * 链接：https://leetcode.cn/problems/number-of-provinces */public class FriendCircles {    /**     * 主方法: 将所有矩阵中的点为机进行判断合并     * @param isConnected  数组     * @return 连接数量     */    public int findCircleNum(int[][] isConnected){        int length = isConnected.length;        UnionSet unionSet = new UnionSet(length);        for (int i = 0; i < length; i++) {            for (int j = i + 1; j < length; j++) {                if (isConnected[i][j] == 1){                    unionSet.union(i,j);                }            }        }        return  unionSet.sets();    }    /**     * 此处多使用一个 Help 数组进行性能的优化 (之前使用栈)     *      ,其中数组和 hash 表的时间复杂度都是 O(1) , 但是相对与 数组和 hash 表而言,数组的常数时间 < hash 表的常数时间     */    public static class UnionSet{        //此数组用于记录查找过程中串联的元素. 便于将链式扁平化,后续查看数据较快        private final int[] help;        //此数组记录每个点为的父节点        private final int[] parents;        //此节点记录期数组中的代表节点所被连接的节点数量        private final int[] size;        //此记录矩阵中的连接个数        private int sets;        UnionSet(int length){            parents = new int[length];            size = new int[length];            sets = length;            help = new int[length];            for (int i = 0; i < length; i++) {                parents[i] = i;                size[i] = 1;            }        }        /**         * 传递一个数组索引位置,返回其对应的最高祖先         *      help[] 是一个查询优化点: 目的为了将链式扁平化         * @param m 数组索引         * @return 最高祖先         */        public int findFather(int m){            int parent = parents[m];            int i = 0;            while (m != parent){                help[i++] = m;                m = parent;                parent = parents[m];            }            while (i > 0){                parents[help[--i]] = parent;            }            return parent;        }        public void union(int i, int j){            int father_o1 = findFather(i);            int father_o2 = findFather(j);            if (father_o1 != father_o2){                int big = size[father_o1] >= size[father_o2] ? father_o1 : father_o2;                int small = big == father_o1 ? father_o2 : father_o1;                parents[small] = big;                size[big] = size[small] + size[big];                sets--;            }        }        public int sets(){            return sets;        }    }}