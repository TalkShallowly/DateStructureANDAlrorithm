package talk.union_find;import java.sql.SQLOutput;import java.util.*;/** * 题目: m 行 n 列的 2d 网格图最初充满水。我们可以执行 addLand 操作， *      将位置 (row, col) 的水变成陆地。给定要操作的位置列表，计算每次 addLand 操作后的岛数。岛屿四面环水，由相邻陆地水平或垂直连接而成。 *       您可以假设网格的所有四个边缘都被水包围 * *       Example: *          Input: m = 3, n = 3, positions = [[0,0], [0,1], [1,2], [2,1]] *          Output: [1,1,2,3] */public class NumberOfIsLands_02 {    public static List<Integer> numIslands_01(int row, int col, int[][] positions){        List<Integer> list = new ArrayList<>();        UnionSet unionSet = new UnionSet(row,col);        for (int[] _val : positions){            list.add(unionSet.contain(_val[0],_val[1]));        }        return list;    }    public static List<Integer> numIslands_02(int row, int col, int[][] positions){        List<Integer> list = new ArrayList<>();        UnionSet_Map unionSetMap = new UnionSet_Map();        for (int[] _val : positions){            list.add(unionSetMap.contain(_val[0],_val[1]));        }        return list;    }    /**     * 样本不是很大,使用其数组并查集策略     */    public static class UnionSet{        private final int[] parents;        private final int[] helps;        private final int[] size;        private final int row;        private final int col;        private int count;        UnionSet(int _row,int _col){            this.row = _row;            this.col = _col;            parents = new int[_row * _col];            helps = new int[_row * _col];            size = new int[_row * _col];        }        public int findFather(int m){            int parent = parents[m];            int i = 0;            while (m != parent){                helps[i++] = m;                m = parent;                parent = parents[m];            }            while (i > 0){                parents[helps[--i]] = parent;            }            return parent;        }        private int getIndex(int _row, int _col){            return (_row * col + _col);        }        private void union(int curRow_o1, int curCol_o1,int curRow_o2,int curCol_o2){            if (curRow_o1 < 0 || curRow_o1 == row || curCol_o1 < 0 || curCol_o1 == col                    || curRow_o2 < 0 || curRow_o2 == row || curCol_o2 < 0 || curCol_o2 == col){                return;            }            int o1 = getIndex(curRow_o1,curCol_o1);            int o2 = getIndex(curRow_o2,curCol_o2);            int father_o1 = findFather(o1);            int father_o2 = findFather(o2);            if (size[o2] != 0 && father_o2 != father_o1){                int big = size[father_o1] >= size[father_o2] ? father_o1 : father_o2;                int small = big == father_o1 ? father_o2 : father_o1;                parents[small] = big;                size[big] = size[father_o1] + size[father_o2];                count--;            }        }        public int contain(int _row, int _col){            if (_row < 0 || _row == row || _col < 0 || _col == col){                return 0;            }            int index = getIndex(_row, _col);            if (size[index] == 0){                parents[index] = index;                count++;                size[index] = 1;                union(_row, _col,_row - 1,_col);                union(_row, _col,_row + 1,_col);                union(_row, _col,_row,_col + 1);                union(_row, _col,_row,_col - 1);            }            return count;        }        public int sets(){            return count;        }    }    /**     * 当样本容量非常大时, 却给定的 positions 很少,可以使用 HashMap 并查集方式     */    public static class UnionSet_Map{        private final HashMap<String,String> parents;        private final HashMap<String,Integer> sizes;        private final Stack<String> helpStack;        UnionSet_Map(){            parents = new HashMap<>();            sizes = new HashMap<>();            helpStack = new Stack<>();        }        public String findFather(String key){            String parent = key;            if (parents.containsKey(key)){                parent = parents.get(key);                while (!Objects.equals(parent, key)){                    helpStack.add(key);                    key = parent;                    parent = parents.get(key);                }                while (!helpStack.isEmpty()){                    parents.put(helpStack.pop(),parent);                }            }            return parent;        }        public void union(String key_o1, String key_o2){            String father_01 = findFather(key_o1);            String father_02 = findFather(key_o2);            if (!Objects.equals(father_01, father_02)){                if (sizes.containsKey(father_01) && sizes.containsKey(father_02)){                    String big = sizes.get(father_01) >= sizes.get(father_02) ?  father_01 : father_02;                    String small = Objects.equals(big, father_01) ? father_02 : father_01;                    parents.put(small,big);                    sizes.put(big,sizes.get(father_01) + sizes.get(father_02));                    sizes.remove(small);                }            }        }        public int contain(int row, int col){            String key = row + "_" + col;            if (!parents.containsKey(key)) {                parents.put(key, key);                sizes.put(key, 1);                union(key, (row - 1) + "_" + col);                union(key, (row + 1) + "_" + col);                union(key, row + "_" + (col - 1));                union(key, row + "_" + (col + 1));            }            return sizes.size();        }    }    private static int[][] generateTestArray(int row , int col, int maxArrNum){        int length = (int)(Math.random() * maxArrNum) + 1;        int[][] positions = new int[length][2];        for (int i = 0; i < length; i++) {            int[] position = new int[2];            position[0] = (int)(Math.random() * row);            position[1] = (int)(Math.random() * col);            positions[i] = position;        }        return positions;    }    public static void main(String[] args) {        int m = 10;        int n = 10;//        int[][] positions = {{1,1},{2,2},{3,0},{1,2},{1,2},{2,3},{1,2},{2,3},{0,1}};//        List<Integer> list = numIslands_02(m, n, positions);//        list.forEach(System.out::println);        int maxArrNum = 90;        int testCount = 10000;        System.out.println("Start........");        for (int p = 0; p < testCount; p++) {            int[][] positions = generateTestArray(m, n, maxArrNum);            List<Integer> list_01 = numIslands_01(m, n, positions);            List<Integer> list_02 = numIslands_02(m, n, positions);            if (list_01.size() != list_02.size()){                System.out.println("Oops...");            }else {                for (int i = 0; i < list_01.size(); i++) {                    if (!Objects.equals(list_01.get(i), list_02.get(i))){                        System.out.println(list_01.get(i) + " ==== " + list_02.get(i));                        System.out.println("Oops");                    }                }            }        }        System.out.println("Finish.......");    }    public static List<Integer> numIslands_03(int m, int n, int[][] positions) {        UnionFind1 uf = new UnionFind1(m, n);        List<Integer> ans = new ArrayList<>();        for (int[] position : positions) {            ans.add(uf.connect(position[0], position[1]));        }        return ans;    }    public static class UnionFind1 {        private int[] parent;        private int[] size;        private int[] help;        private final int row;        private final int col;        private int sets;        public UnionFind1(int m, int n) {            row = m;            col = n;            sets = 0;            int len = row * col;            parent = new int[len];            size = new int[len];            help = new int[len];        }        private int index(int r, int c) {            return r * col + c;        }        private int find(int i) {            int hi = 0;            while (i != parent[i]) {                help[hi++] = i;                i = parent[i];            }            for (hi--; hi >= 0; hi--) {                parent[help[hi]] = i;            }            return i;        }        private void union(int r1, int c1, int r2, int c2) {            if (r1 < 0 || r1 == row || r2 < 0 || r2 == row || c1 < 0 || c1 == col || c2 < 0 || c2 == col) {                return;            }            int i1 = index(r1, c1);            int i2 = index(r2, c2);            if (size[i1] == 0 || size[i2] == 0) {                return;            }            int f1 = find(i1);            int f2 = find(i2);            if (f1 != f2) {                if (size[f1] >= size[f2]) {                    size[f1] += size[f2];                    parent[f2] = f1;                } else {                    size[f2] += size[f1];                    parent[f1] = f2;                }                sets--;            }        }        public int connect(int r, int c) {            int index = index(r, c);            if (size[index] == 0) {                parent[index] = index;                size[index] = 1;                sets++;                union(r - 1, c, r, c);                union(r + 1, c, r, c);                union(r, c - 1, r, c);                union(r, c + 1, r, c);            }            return sets;        }    }}