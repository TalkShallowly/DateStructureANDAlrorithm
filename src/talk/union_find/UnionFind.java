package talk.union_find;import java.util.HashMap;import java.util.List;import java.util.Stack;/** * 并查集结构: 主要解决连通性问题, 时间复杂度均摊下来 O(1) *     此类实现基本的并查集结构 --> 使用 hashMap 实现 *          此并查集中的是哪个优化点: *              1: 小节点 挂 大节点  --> 减少指针的移动 *              2: 有 map 代替指针  --> HashMap 时间复杂度为 O(1) *              3: 链式扁平化处理    --> 便于之后的查找节点时,消耗的性能最小 */public class UnionFind {    /**     * 将数据进行进一步封装, 此后根据Node 类进行信息的记录     */    public static class Node<V>{        private final V value;        Node(V _value){            this.value = _value;        }    }    public static class UnionSet<V>{        //所有 value对应的 Node 封装索引表        private final HashMap<V, Node<V>> nodes;        //Node 节点的祖先节点的索引表        private final HashMap<Node<V>, Node<V>> parents;        //当前矩阵中的代表节点对应的子节点的数量        private final HashMap<Node<V>, Integer> sizeMap;        //初始化进行数据封装        UnionSet(List<V> values){            nodes = new HashMap<>();            parents = new HashMap<>();            sizeMap = new HashMap<>();            for (V val : values){                Node<V> node = new Node<>(val);                nodes.put(val, node);                //刚开始的时候,自己就是自己的父节点                parents.put(node, node);                //并切每个代表节点都是自己,所以此处节点长度就是自己                sizeMap.put(node, 1);            }        }        /**         * 并查集核心逻辑: 给定一个节点,返回最顶级的祖先节点         * @param cur 当前节点         * @return 祖先节点         */        public Node<V> findFather(Node<V> cur) {            Node<V> vNode = cur;            while (cur != parents.get(cur)){                cur = parents.get(cur);            }            return vNode;        }        /**         * 并查集核心逻辑 ---> 优化 (在查找的过程中,一条链向上的路径中的节点数量记录到栈中,查询结束后再将栈中的元素一次连接到祖节点下)         *                   思路: 链式扁平化         * @param cur 当前节点         * @return 祖先节点         */        public Node<V> findFather_optimization(Node<V> cur) {            Node<V> vNode = cur;            Stack<Node<V>> stack = new Stack<>();            while (cur != parents.get(cur)){                stack.push(cur);                cur = parents.get(cur);            }            while (!stack.isEmpty()){                parents.put(stack.pop(),cur);            }            return vNode;        }        /**         * 是否包含 (两个节点的父节点是同一个)         */        public boolean isSameSet(V o1, V o2){            return findFather(nodes.get(o1)) == findFather(nodes.get(o2));        }        /**         * 以下为合并操作 (将两个节点合并)         */        public void union(V o1, V o2){            //获取期每个节点对应的父节点            Node<V> father_o1 = findFather(nodes.get(o1));            Node<V> father_o2 = findFather(nodes.get(o2));            //是否为同一个, 如果不是才合并 (此处合并条件 : 由小节点去挂到大节点的下面)            if (father_o1 != father_o2){                //查找大小节点                Node<V> bigNode = sizeMap.get(father_o1) >= sizeMap.get(father_o2) ? father_o1 : father_o2;                Node<V> smallNode = bigNode == father_o1 ? father_o2 : father_o1;                //将小节点的指针指向大的节点                parents.put(smallNode,bigNode);                //将代表节点的节点数量更新                sizeMap.put(bigNode,sizeMap.get(father_o1) + sizeMap.get(father_o2));                //移除之前小节点的代表节点记录                sizeMap.remove(smallNode);            }        }        /**         * 返回矩阵中中的代表节点数量         */        public int sets(){            return sizeMap.size();        }    }}