package talk.kmp;import talk.tree.treeTraversal.TreeSerializeAndDeserialize;import java.util.*;/** * * 一棵树的子树问题: * *   给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。 *   二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。 * * https://leetcode.cn/problems/subtree-of-another-tree/ */public class TreeEqual {    static class TreeNode{        private  int val;        private  TreeNode left;        private  TreeNode right;        TreeNode(int _val){            this.val = _val;        }        TreeNode(int _val, TreeNode _left, TreeNode _right){            this.val = _val;            this.left = _left;            this.right = _right;        }    }    public static boolean isSubtree(TreeNode root, TreeNode subRoot) {        if (root == null || subRoot == null){            return false;        }        //先序遍历序列化数        String[] source = preSerialization(root);        String[] target =  preSerialization(subRoot);        System.out.println(Arrays.toString(source));        System.out.println(Arrays.toString(target));        return kmp(source, target);    }    private static boolean kmp(String[] source, String[] target){        int[] indexInfo = indexInfo(target);        System.out.println(Arrays.toString(indexInfo));        int sourcePoint = 0;        int targetPoint = 0;        while (sourcePoint < source.length && targetPoint < target.length){            if (source[sourcePoint].equals(target[targetPoint])){                sourcePoint++;                targetPoint++;            }else if (targetPoint == 0){                sourcePoint++;            }else {                targetPoint = indexInfo[targetPoint];            }        }        return targetPoint == target.length;    }    //kmp 小标信息计算    private static int[] indexInfo(String[] str){        if (str.length == 1){            return new int[]{-1};        }else if (str.length == 2){            return new int[]{-1,0};        }else {            int[] ints = new int[str.length];            ints[0] = -1;            ints[1] = 0;            int curPoint = 0;            for (int i = 2; i < str.length;) {                if (str[i - 1].equals(str[curPoint])){                    ints[i++] = ++curPoint;                }else if (curPoint > 0) {                    curPoint = ints[curPoint];                }else {                    ints[i++] = 0;                }            }            return ints;        }    }    /**     * 先序遍历 序列化     * @param head 头节点     * @return 序列化数组     */    private static String[] preSerialization(TreeNode head){        Stack<TreeNode> stack = new Stack<>();        stack.push(head);        List<String> list = new ArrayList<>();        while (!stack.isEmpty()){            TreeNode pop = stack.pop();            list.add(String.valueOf(pop.val));            if (pop.right != null){                stack.push(pop.right);            }            if (pop.left != null){                if (pop.right == null){                    list.add("#");                }                stack.push(pop.left);            } else {                if (pop.right == null){                    list.add("#");                    list.add("#");                }            }        }        String[] str = new String[list.size()];        for (int i = 0; i < list.size(); i++) {            str[i] = list.get(i);        }        return str;    }    public static TreeNode levelDeserialization(String[] strs){        if (strs == null || strs.length < 1){            return null;        }        TreeNode head = new TreeNode(Integer.parseInt(strs[0]));        TreeNode curNode;        Queue<TreeNode> queue = new LinkedList<>();        queue.add(head);        int i = 1;        while (i < strs.length && !queue.isEmpty()){            curNode = queue.poll();            if (strs[i] != "null"){                curNode.left = new TreeNode(Integer.parseInt(strs[i]));                queue.add(curNode.left);            }            i++;            if (strs[i] != "null"){                curNode.right = new TreeNode(Integer.parseInt(strs[i]));                queue.add(curNode.right);            }            i++;        }        return head;    }    public static void main(String[] args) {        TreeNode node = new TreeNode(1);//        node.right = new TreeNode(1);        node.left = new TreeNode(1);//        node.right.right = new TreeNode(1);//        node.right.left = new TreeNode(2);//        node.right.left.right = new TreeNode(0);//        node.left.right = new TreeNode(6);        node.left.left = new TreeNode(1);        node.left.left.right = new TreeNode(2);        //[-1, 0, 0, 0, 1, 2, 0, 0]        //[-1, 0, 0, 0, 0, 0, 0, 0]        TreeNode node1 = new TreeNode(1);        node1.left = new TreeNode(1);        node1.left.right = new TreeNode(2);//        node1.right.right = new TreeNode(4);//        node1.right.left = new TreeNode(5);//        node1.left.right = new TreeNode(6);//        node1.left.left = new TreeNode(7);//        [1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,null,1,2]        String[] source = {"9","-1","null","-2","0","-4","null","null","8","-5","-3","6","null","null","null","null","null","null","7"};        String[] target = {"-1","-2","0","null","null","null","8","6","null","null","7"};        //[9,-1,null,-2,0,-4,null,null,8,-5,-3,6,null,null,null,null,null,null,7]        TreeNode treeNode = levelDeserialization(source);        TreeNode treeNode2 = levelDeserialization(target);        String[] strings = preSerialization(treeNode);        String[] strings2 = preSerialization(treeNode2);        System.out.println(Arrays.toString(strings));        System.out.println("-----");        boolean subtree = isSubtree(treeNode, treeNode2);        System.out.println(subtree);        int index = KMP.indexOf(Arrays.toString(strings), Arrays.toString(strings2));        System.out.println(index);    }}