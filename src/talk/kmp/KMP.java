package talk.kmp;import java.util.Arrays;/** * 字符串匹配算法 KMP: *      利用搜索串的最长前缀与后缀的相等匹配信息 (在不可以取整体串的情况下), 进行优化加速 * *      eg: *          source = AAAAAAAAAAB; *          target = AAAB; * * *          若是以 B 为标准, 最长串[AAA], (不能取整体的情况下), * *          计算 target 子串信息 [-1,0,2,0] * *          假设 20 位置的信息为 7 *           {{0 ~ 2} A {4 ~ 6}] b c d d e [13 ~ 19] k ? *                             3 *          21位置的数如果 b == k, 则 21 位置的信息为 20 + 1 * *                       b != k, 则 [0 ~ 6] b 中 b 的信息为标准, 则跳转为 A 与 k 进行比较, 此时 21 位置的信息与 b 位置有关... 依次推理 * */public class KMP {    public static boolean check(String source, String target){        return source == null || source.length() == 0 || target == null || target.length() == 0 || target.length() > source.length();    }    public static int indexOf(String source, String target){        if (check(source,target)){            return -1;        }        char[] sourceChars = source.toCharArray();        char[] targetChars = target.toCharArray();        //被搜索串指针        int curSourcePoint = 0;        //搜索串指针        int curTargetPoint = 0;        //获取搜索串的每个位置的最长前缀和后缀的相等匹配信息        // O(M) m <= n        int[] targetIndexInfo = getIndexInfo(targetChars);        System.out.println(Arrays.toString(targetIndexInfo));        //curSourcePoint 越界,表示没找到        //curTargetPoint 越界,则匹配成功        while (curSourcePoint < sourceChars.length && curTargetPoint < targetChars.length){            //            if (sourceChars[curSourcePoint] == targetChars[curTargetPoint]){                curSourcePoint++;                curTargetPoint++;            }            // targetIndexInfo[curTargetPoint] 为 -1 时, 则匹配 0 ~ curSourcePoint 完所有的信息为找到            // O(N)            else if (targetIndexInfo[curTargetPoint] != -1){                //targetIndexInfo[curTargetPoint] 为不相等位置的 最长前缀和后缀的相等匹配信息                //此时需要 curTargetPoint 跳跃到 匹配信息进行下次查询                curTargetPoint = targetIndexInfo[curTargetPoint];            }            //以下一个元素为开头重新进行匹配            else {                curSourcePoint++;            }        }        return curTargetPoint == targetChars.length ? curSourcePoint - curTargetPoint : -1;    }    public static int[] getIndexInfo(char[] source){        //0 位置的元素为 -1        //1 位置的元素为 0        if (source.length == 1){            return new int[]{-1};        }else if (source.length == 2){            return new int[]{-1,0};        }else {            int[] ints = new int[source.length];            ints[0] = -1;            ints[1] = 0;            int i = 2; //目前在哪个位置上求next数组的值            int movePoint = 0;  //当前是哪个位置的值再和i-1位置的字符比较            while (i < source.length) {                //判断前一位置,与移动指针所在位置的数据是否相同                if (source[i - 1] == source[movePoint]){                    //数组下标换算, 在对 ints[i]进行赋值时候, 对 i 进行移动                    // movePoint 记录 比较位置的前后缀最长相等信息, 当前 位置依赖 被比较位置, 根据规律,若相等,则比较位置信息 + 1, 即为当前位置信息                    ints[i++] = ++movePoint;                }                //还有可比较的信息                else if (movePoint > 0){                    //将当前比较指针 移动到当前 比较者的匹配信息                    movePoint = ints[movePoint];                }                //没有比较的信息                else {                    ints[i++] = 0;                }            }            return ints;        }    }    private static String generateRandomString(int maxLen){        String template = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";        char[] chars = template.toCharArray();        int len = (int)(Math.random() * maxLen) + 1;        StringBuilder sb = new StringBuilder();        char[] res = new char[len];        for (int i = 0; i < len; i++) {            sb.append(chars[(int)(Math.random() * chars.length)]);        }        return sb.toString();    }    public static void main(String[] args) {        String source = "1##1##1#2##";        String target = "1##1#2##";        System.out.println(indexOf(source, target));//        System.out.println(getIndexOf(source,target));        System.out.println(source.indexOf(target));//        int lenMax = 200000;//        int testCount = 100000;//        System.out.println("测试开始!");//        for (int i = 0; i < testCount; i++) {//            String source = generateRandomString(lenMax);//            String target = generateRandomString(lenMax / 2000);//            int test = source.indexOf(target);//            int kmp = indexOf(source, target);//            if (kmp != test){//                System.out.println("source : ---  " + source);//                System.out.println("target : ---  " + target);//                System.out.println("kmp: " + kmp + "   == test : " + test);//                return;//            }//        }//        System.out.println("测试结束!");    }}